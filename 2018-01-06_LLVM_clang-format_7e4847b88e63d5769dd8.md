<!--
title:   [翻訳] LLVMコーディング標準(6.0.0)
tags:    C++=11,LLVM,clang-format,コーディング規約,翻訳
id:      7e4847b88e63d5769dd8
private: false
-->
# LLVMコーディング標準

LLVMはきれいな設計のコンパイラ基盤で、近年急速に普及が進んでいます。LLVMの一部としてリリースされているコンパイラ`clang`は、macOSやiOS、FreeBSD、OpenBSDの標準コンパイラとして採用されています。

本記事は、LLVMプロジェクトで用いられているコーディング標準（[LLVM Coding Standards](http://releases.llvm.org/6.0.0/docs/CodingStandards.html)）について、原文を読みながらまとめたメモです。原文の翻訳が主ですが、センテンスを一部消したり、補ったりしています。章立てはいじっていません。
随時最新版に追従する予定です。現在は6.0.0版に基づいています。

解釈誤りや分かりづらさの指摘は、コメントや編集リクエストでいただけたら幸いです。

[原文のcurrent版はこちら](http://llvm.org/docs/CodingStandards.html)

## 目次

- [はじめに](#はじめに)
    - [言語、ライブラリ、および標準](#言語ライブラリおよび標準)
    - [C++標準のバージョン](#c標準のバージョン)
    - [C++標準ライブラリ](#c標準ライブラリ)
    - [利用するC++11言語とライブラリの機能](#利用するc11言語とライブラリの機能)
    - [その他の言語](#その他の言語)
- [機械的なソースの問題](#機械的なソースの問題)
    - [ソースコードのフォーマット](#ソースコードのフォーマット)
        - [コメント](#コメント)
            - [ファイルのヘッダ](#ファイルのヘッダ)
            - [クラス概要](#クラス概要)
            - [メソッド情報](#メソッド情報)
        - [コメント書式](#コメント書式)
        - [ドキュメントコメントでのDoxygenの使用](#ドキュメントコメントでのdoxygenの使用)
        - [`#include`の形式](#includeの形式)
        - [ソースコードの幅](#ソースコードの幅)
        - [タブの代わりにスペースを使う](#タブの代わりにスペースを使う)
        - [インデントの一貫](#インデントの一貫)
            - [ラムダはコードブロックと同様に整形](#ラムダはコードブロックと同様に整形)
            - [ブレース初期化子リスト](#ブレース初期化子リスト)
    - [言語とコンパイラの問題](#言語とコンパイラの問題)
        - [コンパイラ警告はエラーと同様に扱う](#コンパイラ警告はエラーと同様に扱う)
        - [移植可能なコードを書く](#移植可能なコードを書く)
        - [RTTIや例外を使わない](#rttiや例外を使わない)
        - [静的コンストラクタを使わない](#静的コンストラクタを使わない)
        - [`class`と`struct`キーワードの使い方](#classとstructキーワードの使い方)
        - [ブレース初期化子リストはコンストラクタ呼び出しに使わない](#ブレース初期化子リストはコンストラクタ呼び出しに使わない)
        - [コードを読みやすくするために`auto`型推論を使う](#コードを読みやすくするためにauto型推論を使う)
        - [`auto`での不必要なコピーに注意](#autoでの不必要なコピーに注意)
        - [ポインタ順序による非決定性に注意](#ポインタ順序による非決定性に注意)
- [スタイルの問題](#スタイルの問題)
    - [高位の問題](#高位の問題)
        - [公開ヘッダファイル **は** モジュール](#公開ヘッダファイル-は-モジュール)
        - [`#include`は最低限に](#includeは最低限に)
        - [「内部」ヘッダは非公開](#内部ヘッダは非公開)
        - [早期終了と`continue`でコードをシンプルに](#早期終了とcontinueでコードをシンプルに)
        - [`return`後に`else`を使用しない](#return後にelseを使用しない)
        - [Predicateはループから関数へ](#predicateはループから関数へ)
    - [低位の問題](#低位の問題)
        - [型、関数、変数、および列挙子への適切な命名](#型関数変数および列挙子への適切な命名)
        - [たっぷりのアサート](#たっぷりのアサート)
        - [`using namespace std`を使わない](#using-namespace-stdを使わない)
        - [ヘッダ内クラスは仮想メソッドアンカーを提供する](#ヘッダ内クラスは仮想メソッドアンカーを提供する)
        - [列挙型を網羅したswitchにdefaultを使わない](#列挙型を網羅したswitchにdefaultを使わない)
        - [できるだけrange-based ``for``ループを使う](#できるだけrange-based-forループを使う)
        - [ループで毎回`end()`を評価しない](#ループで毎回endを評価しない)
        - [`#include <iostream>`禁止](#include-iostream禁止)
        - [`raw_ostream`を使う](#raw_ostreamを使う)
        - [`std::endl`を避ける](#stdendlを避ける)
        - [クラス定義内の関数定義で`inline`を使わない](#クラス定義内の関数定義でinlineを使わない)
    - [細かい話](#細かい話)
        - [括弧の前にスペース](#括弧の前にスペース)
        - [前置インクリメントの選好](#前置インクリメントの選好)
        - [名前空間のインデント](#名前空間のインデント)
        - [無名名前空間](#無名名前空間)
- [関連項目](#関連項目)

<!--
Introduction
============

This document attempts to describe a few coding standards that are being used in
the LLVM source tree.  Although no coding standards should be regarded as
absolute requirements to be followed in all instances, coding standards are
particularly important for large-scale code bases that follow a library-based
design (like LLVM).
-->

## はじめに

<!--
While this document may provide guidance for some mechanical formatting issues,
whitespace, or other "microscopic details", these are not fixed standards.
Always follow the golden rule:

.. _Golden Rule:

    **If you are extending, enhancing, or bug fixing already implemented code,
    use the style that is already being used so that the source is uniform and
    easy to follow.**

Note that some code bases (e.g. ``libc++``) have really good reasons to deviate
from the coding standards.  In the case of ``libc++``, this is because the
naming and other conventions are dictated by the C++ standard.  If you think
there is a specific good reason to deviate from the standards here, please bring
it up on the LLVM-dev mailing list.
-->

LLVMコーディング標準は様々な指針を提供しますが、それらは絶対的な標準ではありません。どんな場合も以下の原則が最優先です。

**原則：既存コードを修正/拡張する場合は、そのスタイルを踏まえる。**

注意：一部のコードベースには本文書の標準から逸れる妥当な理由があります。例えば `libc++` の場合、命名規則等がC++標準で定められています。

<!--
There are some conventions that are not uniformly followed in the code base
(e.g. the naming convention).  This is because they are relatively new, and a
lot of code was written before they were put in place.  Our long term goal is
for the entire codebase to follow the convention, but we explicitly *do not*
want patches that do large-scale reformatting of existing code.  On the other
hand, it is reasonable to rename the methods of a class if you're about to
change it in some other way.  Just do the reformatting as a separate commit
from the functionality change.

The ultimate goal of these guidelines is to increase the readability and
maintainability of our common source base. If you have suggestions for topics to
be included, please mail them to `Chris <mailto:sabre@nondot.org>`_.
-->

コードベースにはここの命名規則等に従わないコードも含まれています。長期目標はコードベース全体が規則に沿うことですが、既存コードを大きく整形するパッチは望んで*いません*。一方、機能修正時にそのクラスのメソッド名を直すことは問題ありません。ただしコード整形は機能修正とコミットを分けてください。

本ガイドラインの究極の目標は、コードベースの可読性と保守性を高めることです。

<!--

Languages, Libraries, and Standards
===================================

Most source code in LLVM and other LLVM projects using these coding standards
is C++ code. There are some places where C code is used either due to
environment restrictions, historical restrictions, or due to third-party source
code imported into the tree. Generally, our preference is for standards
conforming, modern, and portable C++ code as the implementation language of
choice.
-->

### 言語、ライブラリ、および標準

規格に準拠したモダンでポータブルなC++コードを、実装言語とします。LLVMや関連プロジェクトのソースコードの大半はC++コードですが、いくつかの部位ではCコードが使われています。これは環境の制約、歴史的な制限、もしくはサードパーティ製コードの利用に由来しています。

<!--

C++ Standard Versions
---------------------

LLVM, Clang, and LLD are currently written using C++11 conforming code,
although we restrict ourselves to features which are available in the major
toolchains supported as host compilers. The LLDB project is even more
aggressive in the set of host compilers supported and thus uses still more
features. Regardless of the supported features, code is expected to (when
reasonable) be standard, portable, and modern C++11 code. We avoid unnecessary
vendor-specific extensions, etc.
-->

### C++標準のバージョン

LLVM、Clang、そしてLLDは現在C++11に準じて書かれていますが、開発環境としてサポートするホストコンパイラで利用可能な機能に限定しています。LLDBプロジェクトはよりアグレッシブにコンパイラを選んでいるため、より多くの機能を使えます。ホストコンパイラの機能に関わらず、コードは（合理的な範囲で）規格に準拠しモダンでポータブルなC++11コードであることが期待されます。不要なベンダー拡張等は避けます。

<!--

C++ Standard Library
--------------------

Use the C++ standard library facilities whenever they are available for
a particular task. LLVM and related projects emphasize and rely on the standard
library facilities for as much as possible. Common support libraries providing
functionality missing from the standard library for which there are standard
interfaces or active work on adding standard interfaces will often be
implemented in the LLVM namespace following the expected standard interface.

There are some exceptions such as the standard I/O streams library which are
avoided. Also, there is much more detailed information on these subjects in the
:doc:`ProgrammersManual`.
-->

### C++標準ライブラリ

C++標準ライブラリを活用してください。標準ライブラリで実装が追い付いていない機能は、LLVM名前空間内に共通サポートライブラリとして、期待される標準インタフェースに沿って実装されます。

いくつかの例外があります（標準I/Oストリームを使わない等）。詳細は[LLVM Programmer’s Manual](http://llvm.org/docs/ProgrammersManual.html)を参照してください。

<!--

Supported C++11 Language and Library Features
---------------------------------------------

While LLVM, Clang, and LLD use C++11, not all features are available in all of
the toolchains which we support. The set of features supported for use in LLVM
is the intersection of those supported in the minimum requirements described
in the :doc:`GettingStarted` page, section `Software`.
The ultimate definition of this set is what build bots with those respective
toolchains accept. Don't argue with the build bots. However, we have some
guidance below to help you know what to expect.

Each toolchain provides a good reference for what it accepts:

* Clang: http://clang.llvm.org/cxx_status.html
* GCC: http://gcc.gnu.org/projects/cxx0x.html
* MSVC: http://msdn.microsoft.com/en-us/library/hh567368.aspx

In most cases, the MSVC list will be the dominating factor. Here is a summary
of the features that are expected to work. Features not on this list are
unlikely to be supported by our host compilers.
-->

### 利用するC++11言語とライブラリの機能

LLVM内で用いるのは、C++11のうち[Getting Started with the LLVM System](http://releases.llvm.org/6.0.0/docs/GettingStarted.html)に記載された最小要件上でサポートされる機能に限ります。LLVM6.0.0では、Clang 3.1、GCC 4.8、Visual Studio 2015(Update3)です。最終的な定義は「要件の各ツールチェインでビルド可能であること」ですが、いくつか指針を示します。

どのツールチェインも、サポートする言語機能の良い資料を提供しています。

- Clang: <http://clang.llvm.org/cxx_status.html>
- GCC: <http://gcc.gnu.org/projects/cxx0x.html>
- MSVC: <http://msdn.microsoft.com/en-us/library/hh567368.aspx>[^1]

[^1]: 対応すると思われる日本語ページ <https://docs.microsoft.com/ja-jp/cpp/visual-cpp-language-conformance>

ほとんどの場合、MSVCが支配的要因となります。以下に動くであろう機能をざっと示します。リストにない機能はおそらく動かないでしょう。

<!--
* Rvalue references: N2118_

  * But *not* Rvalue references for ``*this`` or member qualifiers (N2439_)

* Static assert: N1720_
* ``auto`` type deduction: N1984_, N1737_
* Trailing return types: N2541_
* Lambdas: N2927_

  * But *not* lambdas with default arguments.

* ``decltype``: N2343_
* Nested closing right angle brackets: N1757_
* Extern templates: N1987_
* ``nullptr``: N2431_
* Strongly-typed and forward declarable enums: N2347_, N2764_
* Local and unnamed types as template arguments: N2657_
* Range-based for-loop: N2930_

  * But ``{}`` are required around inner ``do {} while()`` loops.  As a result,
    ``{}`` are required around function-like macros inside range-based for
    loops.

* ``override`` and ``final``: N2928_, N3206_, N3272_
* Atomic operations and the C++11 memory model: N2429_
* Variadic templates: N2242_
* Explicit conversion operators: N2437_
* Defaulted and deleted functions: N2346_
* Initializer lists: N2627_
* Delegating constructors: N1986_
* Default member initializers (non-static data member initializers): N2756_

  * Feel free to use these wherever they make sense and where the `=`
    syntax is allowed. Don't use braced initialization syntax.

.. _N2118: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2118.html
.. _N2439: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2439.htm
.. _N1720: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1720.html
.. _N1984: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1984.pdf
.. _N1737: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1737.pdf
.. _N2541: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2541.htm
.. _N2927: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf
.. _N2343: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2343.pdf
.. _N1757: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1757.html
.. _N1987: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1987.htm
.. _N2431: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2431.pdf
.. _N2347: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf
.. _N2764: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2764.pdf
.. _N2657: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2657.htm
.. _N2930: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2930.html
.. _N2928: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2928.htm
.. _N3206: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3206.htm
.. _N3272: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3272.htm
.. _N2429: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2429.htm
.. _N2242: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2242.pdf
.. _N2437: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2437.pdf
.. _N2346: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2346.htm
.. _N2627: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2672.htm
.. _N1986: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1986.pdf
.. _N2756: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2756.htm
-->

<!-- textlint-disable -->

- 右辺値参照(Rvalue references): [N2118](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2118.html)
  - ただし、 `*this` やメンバ関数への修飾については、右辺値参照 *禁止*
- Static assert: [N1720](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1720.html)
- `auto` 型推論: [N1984](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1984.pdf), [N1737](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1737.pdf)
- 後置戻り型: [N2541](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2541.htm)
- ラムダ: [N2927](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf)
  - ただし、デフォルト引数と合わせての利用は *禁止* 。
- `decltype`: [N2343](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2343.pdf)
- 連続する閉じ山かっこ: [N1757](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1757.html)
- Extern templates: [N1987](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1987.htm)
- `nullptr`: [N2431](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2431.pdf)
- 厳密に型付けされ、前方宣言可能なenum: [N2347](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf), [N2764](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2764.pdf)
- ローカル型や無名型のテンプレート引数: [N2657](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2657.htm)
- 範囲によるforループ: [N2930](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2930.html)
  - `do {} while()` ループを内包する場合には `{}` が必須となります。そのため、ループ内で関数マクロを使う場合も `{}` が必要です。
- `override` および `final`: [N2928](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2928.htm), [N3206](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3206.htm), [N3272](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3272.htm)
- アトミック操作とC++11メモリモデル: [N2429](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2429.htm)
- 可変個引数テンプレート: [N2242](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2242.pdf)
- 明示的な変換演算子: [N2437](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2437.pdf)
- 関数のdefault&delete宣言: [N2346](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2346.htm)
- 初期化子リスト: [N2627](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2672.htm)
- 委譲コンストラクタ: [N1986](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1986.pdf)
- デフォルトのメンバー初期化子（非静的データメンバー初期化子）: [N2756](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2756.htm)
  - `=`構文が許されているところでは自由に使えますが、braded初期化構文は*禁止*。

<!-- textlint-enable -->

<!--
The supported features in the C++11 standard libraries are less well tracked,
but also much greater. Most of the standard libraries implement most of C++11's
library. The most likely lowest common denominator is Linux support. For
libc++, the support is just poorly tested and undocumented but expected to be
largely complete. YMMV. For libstdc++, the support is documented in detail in
`the libstdc++ manual`_. There are some very minor missing facilities that are
unlikely to be common problems, and there are a few larger gaps that are worth
being aware of:

* Not all of the type traits are implemented
* No regular expression library.
* While most of the atomics library is well implemented, the fences are
  missing. Fortunately, they are rarely needed.
* The locale support is incomplete.

Other than these areas you should assume the standard library is available and
working as expected until some build bot tells you otherwise. If you're in an
uncertain area of one of the above points, but you cannot test on a Linux
system, your best approach is to minimize your use of these features, and watch
the Linux build bots to find out if your usage triggered a bug. For example, if
you hit a type trait which doesn't work we can then add support to LLVM's
traits header to emulate it.

.. _the libstdc++ manual:
  http://gcc.gnu.org/onlinedocs/gcc-4.8.0/libstdc++/manual/manual/status.html#status.iso.2011
-->

ほとんどの標準ライブラリは、C++11標準をほぼ全て実装しています。`libc++`は、テストや文書化が不十分ですが、ほぼ完全な実装を見込めます。`libstdc++`の場合は、[the libstdc++ manual](http://gcc.gnu.org/onlinedocs/gcc-4.8.0/libstdc++/manual/manual/status.html#status.iso.2011)で詳細に文書化されています。まず問題ないでしょうが、注意を要する不足がいくつかあります。

- type traitsの一部が未実装
- 正規表現ライブラリなし
- アトミックライブラリの内、フェンスがない
- ロケールのサポートが不完全

これら以外については、標準ライブラリが使えると想定して進めてよいでしょう。何かあれば自動ビルドで発覚します。例えば、もしtype traitの未実装を踏んで見つけてしまった場合は、それをエミュレートするようLLVMのtraitsヘッダにサポートを追加できます。

<!--

Other Languages
---------------

Any code written in the Go programming language is not subject to the
formatting rules below. Instead, we adopt the formatting rules enforced by
the `gofmt`_ tool.

Go code should strive to be idiomatic. Two good sets of guidelines for what
this means are `Effective Go`_ and `Go Code Review Comments`_.

.. _gofmt:
  https://golang.org/cmd/gofmt/

.. _Effective Go:
  https://golang.org/doc/effective_go.html

.. _Go Code Review Comments:
  https://github.com/golang/go/wiki/CodeReviewComments
-->

### その他の言語

Go言語で記述されたコードは、以降の書式ルールの対象にはなりません。その代わりに、 [gofmt](https://golang.org/cmd/gofmt/) ツールによる整形を採用しています。

Goコードは慣習に倣うよう努めてください。[Effective Go](https://golang.org/doc/effective_go.html) および [Go Code Review Comments](https://github.com/golang/go/wiki/CodeReviewComments) [^2]の2つが良いガイドラインとなります。

[^2]: 翻訳記事：[#golang CodeReviewComments 日本語翻訳](http://qiita.com/knsh14/items/8b73b31822c109d4c497)

<!--

Mechanical Source Issues
========================

Source Code Formatting
----------------------

Commenting
^^^^^^^^^^

Comments are one critical part of readability and maintainability.  Everyone
knows they should comment their code, and so should you.  When writing comments,
write them as English prose, which means they should use proper capitalization,
punctuation, etc.  Aim to describe what the code is trying to do and why, not
*how* it does it at a micro level. Here are a few critical things to document:

.. _header file comment:
-->

## 機械的なソースの問題

### ソースコードのフォーマット

#### コメント

可読性と保守性を高めるため、コメントを入れてください。英文で、適切な句読点と大小文字で書いてください。コードがなにを行おうとしているのか、またなぜ（why）行おうとしているのかを説明することに焦点を絞り、微細に *どうやるか（how）* を書くことは避けてください。重要な事柄をいくつか示します。

<!--
File Headers
""""""""""""

Every source file should have a header on it that describes the basic purpose of
the file.  If a file does not have a header, it should not be checked into the
tree.  The standard header looks like this:

.. code-block:: c++

  //===-- llvm/Instruction.h - Instruction class definition -------*- C++ -*-===//
  //
  //                     The LLVM Compiler Infrastructure
  //
  // This file is distributed under the University of Illinois Open Source
  // License. See LICENSE.TXT for details.
  //
  //===----------------------------------------------------------------------===//
  ///
  /// \file
  /// This file contains the declaration of the Instruction class, which is the
  /// base class for all of the VM instructions.
  ///
  //===----------------------------------------------------------------------===//
-->

##### ファイルのヘッダ

すべてのソースファイルには、ファイルの基本的な目的を説明するヘッダコメントが必要です。ファイルにヘッダがない場合チェックイン禁止です。

```cpp:標準のファイルヘッダ
  //===-- llvm/Instruction.h - Instruction class definition -------*- C++ -*-===//
  //
  //                     The LLVM Compiler Infrastructure
  //
  // This file is distributed under the University of Illinois Open Source
  // License. See LICENSE.TXT for details.
  //
  //===----------------------------------------------------------------------===//
  ///
  /// \file
  /// This file contains the declaration of the Instruction class, which is the
  /// base class for all of the VM instructions.
  ///
  //===----------------------------------------------------------------------===//
```

<!--
A few things to note about this particular format: The "``-*- C++ -*-``" string
on the first line is there to tell Emacs that the source file is a C++ file, not
a C file (Emacs assumes ``.h`` files are C files by default).

.. note::

    This tag is not necessary in ``.cpp`` files.  The name of the file is also
    on the first line, along with a very short description of the purpose of the
    file.  This is important when printing out code and flipping though lots of
    pages.

The next section in the file is a concise note that defines the license that the
file is released under.  This makes it perfectly clear what terms the source
code can be distributed under and should not be modified in any way.

The main body is a ``doxygen`` comment (identified by the ``///`` comment
marker instead of the usual ``//``) describing the purpose of the file.  The
first sentence (or a passage beginning with ``\brief``) is used as an abstract.
Any additional information should be separated by a blank line.  If an
algorithm is being implemented or something tricky is going on, a reference
to the paper where it is published should be included, as well as any notes or
*gotchas* in the code to watch out for.
-->

1行目の "`-*- C++ -*-`" は、EmacsにソースファイルがCではなくC++であることを教えます（Emacsはデフォルトで `.h`ファイルをCとして扱います）。このタグは、`.cpp`ファイルでは不要です。最初の行にはファイル名と簡単な説明があります。これはコードを印刷して読む場合に重要です。

ファイルの次のセクションは、ファイルがどのライセンスの元でリリースされたかを簡潔に定義します。これにより、ソースコードがどのような条件の下で配布できるかが明確になります。そのため、どのような形であれ、変更してはいけません。

本体は`doxygen`コメント（通常の`//`ではなく`///`コメントで識別されます）にてファイルの目的を説明します。最初の一文（または`\brief`で始まる段落）は概要として使われます。追加情報は空白行で区切ってください。アルゴリズムの実装では発行論文への参照を含めてください。任意のメモやコードの注意すべき*落とし穴*もあれば記載してください。

<!--
Class overviews
"""""""""""""""

Classes are one fundamental part of a good object oriented design.  As such, a
class definition should have a comment block that explains what the class is
used for and how it works.  Every non-trivial class is expected to have a
``doxygen`` comment block.
-->

##### クラス概要

クラスは良いオブジェクト指向設計の基本的要素です。クラス定義は、クラスが何に使われ、どのように働くかを説明するコメントブロックを持つべきです。自明な場合を除き、`doxygen`コメントブロックを持つことが期待されます。

<!--
Method information
""""""""""""""""""

Methods defined in a class (as well as any global functions) should also be
documented properly.  A quick note about what it does and a description of the
borderline behaviour is all that is necessary here (unless something
particularly tricky or insidious is going on).  The hope is that people can
figure out how to use your interfaces without reading the code itself.

Good things to talk about here are what happens when something unexpected
happens: does the method return null?  Abort?  Format your hard disk?
-->

##### メソッド情報

クラスのメソッド（およびグローバル関数）定義も適切に文書化してください。ここでは、何をするかについての簡単なメモや、境界での挙動の説明のみがあれば十分です（特に凝ったことをしていない場合）。理想は、コードを読まずとも使い方が理解できることです。

想定外の事態に何が起きるかについて触れるとよいでしょう。nullを返す？　強制終了？　ハードディスクの初期化？

<!--
Comment Formatting
^^^^^^^^^^^^^^^^^^

In general, prefer C++ style comments (``//`` for normal comments, ``///`` for
``doxygen`` documentation comments).  They take less space, require
less typing, don't have nesting problems, etc.  There are a few cases when it is
useful to use C style (``/* */``) comments however:

#. When writing C code: Obviously if you are writing C code, use C style
   comments.

#. When writing a header file that may be ``#include``\d by a C source file.

#. When writing a source file that is used by a tool that only accepts C style
   comments.

Commenting out large blocks of code is discouraged, but if you really have to do
this (for documentation purposes or as a suggestion for debug printing), use
``#if 0`` and ``#endif``. These nest properly and are better behaved in general
than C style comments.
-->

#### コメント書式

通常は、C++スタイルのコメントを用います（普通のコメントに`//`、`doxygen`の文書化コメントに`///`）。省スペースで、タイプ数も少なく、入れ子での問題等もありません。ですが、以下のようにCスタイル（`/* */`）を用いたほうが良い場合もあります。

1. Cコードファイル
1. Cソースファイルから`#include`されるヘッダファイル
1. Cスタイルのコメントしか受け付けないツール向けのファイル

大量のコードのコメントアウトがどうしても必要な場合（ドキュメント目的やデバッグプリント案等）は、 `#if 0`と`#endif`を使ってください。Cスタイルコメントよりもうまく働きます。

<!--
Doxygen Use in Documentation Comments
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Use the ``\file`` command to turn the standard file header into a file-level
comment.

Include descriptive paragraphs for all public interfaces (public classes,
member and non-member functions).  Don't just restate the information that can
be inferred from the API name.  The first sentence (or a paragraph beginning
with ``\brief``) is used as an abstract. Try to use a single sentence as the
``\brief`` adds visual clutter.  Put detailed discussion into separate
paragraphs.

To refer to parameter names inside a paragraph, use the ``\p name`` command.
Don't use the ``\arg name`` command since it starts a new paragraph that
contains documentation for the parameter.

Wrap non-inline code examples in ``\code ... \endcode``.

To document a function parameter, start a new paragraph with the
``\param name`` command.  If the parameter is used as an out or an in/out
parameter, use the ``\param [out] name`` or ``\param [in,out] name`` command,
respectively.

To describe function return value, start a new paragraph with the ``\returns``
command.
-->

#### ドキュメントコメントでのDoxygenの使用

`\file`コマンドを使い、標準のファイルヘッダをファイルレベルのコメントにします。

すべての公開インタフェース（publicクラス、メンバーと非メンバー関数）について説明する段落を含めます。API名を読み替えただけの記載にはしないでください。最初の一文（または`\brief`で始まる段落）は概要として使われます。`\brief`は目が滑るため、単一の文を使ってみてください。詳細な議論は段落を分けてください。

段落内で引数名を参照するには、`\p name`コマンドを使います。新たな段落が始まってしまうため、`\arg name`コマンドは使わないでください。

複数行のコード例は、`\code ... \endcode`で囲います。

関数引数の文書化には、`\param name`コマンドを使い新しい段落を始めます。引数が出力または入出力として用いられる場合、それぞれ`\param [out] name`や`\param [in,out] name`コマンドを使います。

関数の戻り値の説明には、`\returns`コマンドを使い新たな段落を始めます。

<!--
A minimal documentation comment:

.. code-block:: c++

  /// Sets the xyzzy property to \p Baz.
  void setXyzzy(bool Baz);

A documentation comment that uses all Doxygen features in a preferred way:

.. code-block:: c++

  /// Does foo and bar.
  ///
  /// Does not do foo the usual way if \p Baz is true.
  ///
  /// Typical usage:
  /// \code
  ///   fooBar(false, "quux", Res);
  /// \endcode
  ///
  /// \param Quux kind of foo to do.
  /// \param [out] Result filled with bar sequence on foo success.
  ///
  /// \returns true on success.
  bool fooBar(bool Baz, StringRef Quux, std::vector<int> &Result);
-->

```cpp:最小限のドキュメントコメント
  /// Sets the xyzzy property to \p Baz.
  void setXyzzy(bool Baz);
```

```cpp:紹介した全機能を使うドキュメントコメント
  /// Does foo and bar.
  ///
  /// Does not do foo the usual way if \p Baz is true.
  ///
  /// Typical usage:
  /// \code
  ///   fooBar(false, "quux", Res);
  /// \endcode
  ///
  /// \param Quux kind of foo to do.
  /// \param [out] Result filled with bar sequence on foo success.
  ///
  /// \returns true on success.
  bool fooBar(bool Baz, StringRef Quux, std::vector<int> &Result);
```

<!--
Don't duplicate the documentation comment in the header file and in the
implementation file.  Put the documentation comments for public APIs into the
header file.  Documentation comments for private APIs can go to the
implementation file.  In any case, implementation files can include additional
comments (not necessarily in Doxygen markup) to explain implementation details
as needed.

Don't duplicate function or class name at the beginning of the comment.
For humans it is obvious which function or class is being documented;
automatic documentation processing tools are smart enough to bind the comment
to the correct declaration.
-->

ヘッダファイルと実装ファイルでドキュメントコメントを重複させないこと。公開APIのドキュメントコメントはヘッダファイルに入れてください。非公開APIのドキュメントコメントは、実装ファイルで結構です。どんな場合でも、実装ファイルには必要に応じて、実装の詳細を説明するための追加コメントを入れられます（Doxygen形式でなくても）。

コメントの先頭に関数名やクラス名をコピーしないでください。関数やクラスが文書化されていることは明らかであり、Doxygenはコメントを正しい宣言に対応付けられます。

<!--
Wrong:

.. code-block:: c++

  // In Something.h:

  /// Something - An abstraction for some complicated thing.
  class Something {
  public:
    /// fooBar - Does foo and bar.
    void fooBar();
  };

  // In Something.cpp:

  /// fooBar - Does foo and bar.
  void Something::fooBar() { ... }
-->

```cpp:誤
  // In Something.h:

  /// Something - An abstraction for some complicated thing.
  class Something {
  public:
    /// fooBar - Does foo and bar.
    void fooBar();
  };

  // In Something.cpp:

  /// fooBar - Does foo and bar.
  void Something::fooBar() { ... }
```

<!--
Correct:

.. code-block:: c++

  // In Something.h:

  /// An abstraction for some complicated thing.
  class Something {
  public:
    /// Does foo and bar.
    void fooBar();
  };

  // In Something.cpp:

  // Builds a B-tree in order to do foo.  See paper by...
  void Something::fooBar() { ... }
-->

```cpp:正
  // In Something.h:

  /// An abstraction for some complicated thing.
  class Something {
  public:
    /// Does foo and bar.
    void fooBar();
  };

  // In Something.cpp:

  // Builds a B-tree in order to do foo.  See paper by...
  void Something::fooBar() { ... }
```

<!--
It is not required to use additional Doxygen features, but sometimes it might
be a good idea to do so.

Consider:

* adding comments to any narrow namespace containing a collection of
  related functions or types;

* using top-level groups to organize a collection of related functions at
  namespace scope where the grouping is smaller than the namespace;

* using member groups and additional comments attached to member
  groups to organize within a class.

For example:

.. code-block:: c++

  class Something {
    /// \name Functions that do Foo.
    /// @{
    void fooBar();
    void fooBaz();
    /// @}
    ...
  };
-->

Doxygenの追加機能を使う必要はありませんが、使ったほうがよい場合もあります。

- 関連する関数や型を含む小さな名前空間へのコメント追加
- 名前空間内で関連する関数を整理するための、トップレベルのグループの使用
- クラス内のメンバーを整理するための、グループ追加

```cpp:例
class Something {
  /// \name Functions that do Foo.
  /// @{
  void fooBar();
  void fooBaz();
  /// @}
  ...
};
```

<!--
``#include`` Style
^^^^^^^^^^^^^^^^^^

Immediately after the `header file comment`_ (and include guards if working on a
header file), the `minimal list of #includes`_ required by the file should be
listed.  We prefer these ``#include``\s to be listed in this order:

.. _Main Module Header:
.. _Local/Private Headers:

#. Main Module Header
#. Local/Private Headers
#. LLVM project/subproject headers (``clang/...``, ``lldb/...``, ``llvm/...``, etc)
#. System ``#include``\s

and each category should be sorted lexicographically by the full path.
-->

#### `#include`の形式

[ファイルヘッダのコメント](#ファイルのヘッダ)（およびヘッダファイルの場合はインクルードガード）直後に、そのファイルに[必要最低限の`#include`](#includeは最低限に)を並べます。`#include`は次の順に並べます。

1. メインモジュールヘッダ
1. ローカル/プライベートヘッダ
1. LLVMプロジェクト/サブプロジェクトのヘッダ（`clang/...`, `lldb/...`, `llvm/...`, ...）
1. システムの`#include`

パスは省略せず、カテゴリごとに辞書順で並べます。

<!--
The `Main Module Header`_ file applies to ``.cpp`` files which implement an
interface defined by a ``.h`` file.  This ``#include`` should always be included
**first** regardless of where it lives on the file system.  By including a
header file first in the ``.cpp`` files that implement the interfaces, we ensure
that the header does not have any hidden dependencies which are not explicitly
``#include``\d in the header, but should be. It is also a form of documentation
in the ``.cpp`` file to indicate where the interfaces it implements are defined.

LLVM project and subproject headers should be grouped from most specific to least
specific, for the same reasons described above.  For example, LLDB depends on
both clang and LLVM, and clang depends on LLVM.  So an LLDB source file should
include ``lldb`` headers first, followed by ``clang`` headers, followed by
``llvm`` headers, to reduce the possibility (for example) of an LLDB header
accidentally picking up a missing include due to the previous inclusion of that
header in the main source file or some earlier header file.  clang should
similarly include its own headers before including llvm headers.  This rule
applies to all LLVM subprojects.
-->

メインモジュールヘッダファイルは、`.h`ファイルで定義されたインタフェースを実装する`.cpp`ファイルに適用されます。この`#include`は、それがファイルシステムのどこにあるかに関わらず、**最初に**includeされるべきです。`.cpp`ファイルが実装するインタフェースをファイル先頭でincludeすることにより、ヘッダ内の`#include`に含まれない依存関係が無いことを確認できます。暗黙の依存関係があった場合、コンパイルエラーとなってくれます。また、`.cpp`の実装するインタフェースがどこで定義されているかを示す一種のドキュメントにもなります。

LLVMプロジェクトとサブプロジェクトのヘッダでは、同様の理由で具体性の高いものから順にグループ分けします。例えば、LLDBはclangとLLVMに依存しclangはLLVMに依存します。そのため、LLDBのソースファイルは`lldb`、`clang`、`llvm`の順にヘッダファイルをインクルードします。これにより、LLDBヘッダファイルから必要なインクルードが漏れてしまう可能性を減らします。clangでも同様に、LLVMヘッダの前に独自ヘッダをインクルードします。このルールは、すべてのLLVMサブプロジェクトに適用されます。

<!--
.. _fit into 80 columns:
Source Code Width
^^^^^^^^^^^^^^^^^

Write your code to fit within 80 columns of text.  This helps those of us who
like to print out code and look at your code in an ``xterm`` without resizing
it.

The longer answer is that there must be some limit to the width of the code in
order to reasonably allow developers to have multiple files side-by-side in
windows on a modest display.  If you are going to pick a width limit, it is
somewhat arbitrary but you might as well pick something standard.  Going with 90
columns (for example) instead of 80 columns wouldn't add any significant value
and would be detrimental to printing out code.  Also many other projects have
standardized on 80 columns, so some people have already configured their editors
for it (vs something else, like 90 columns).

This is one of many contentious issues in coding standards, but it is not up for
debate.
-->

#### ソースコードの幅

80桁に収めてください。これは、コードを印刷したり、`xterm`上でサイズを変えず読みたい人の助けになります。また、多くの他プロジェクトでも80桁が採用されているため、多くの人はエディタをそのように設定しています。

<!--
Use Spaces Instead of Tabs
^^^^^^^^^^^^^^^^^^^^^^^^^^

In all cases, prefer spaces to tabs in source files.  People have different
preferred indentation levels, and different styles of indentation that they
like; this is fine.  What isn't fine is that different editors/viewers expand
tabs out to different tab stops.  This can cause your code to look completely
unreadable, and it is not worth dealing with.

As always, follow the `Golden Rule`_ above: follow the style of
existing code if you are modifying and extending it.  If you like four spaces of
indentation, **DO NOT** do that in the middle of a chunk of code with two spaces
of indentation.  Also, do not reindent a whole source file: it makes for
incredible diffs that are absolutely worthless.
-->

#### タブの代わりにスペースを使う

ソースファイルではタブよりもスペースがよいです。タブは表示環境ごとに異なるタブストップで展開され崩れる恐れがあります。

いつものように[原則](#はじめに)に従いましょう。既存コードに手を入れる場合、既存のスタイルに準じます。4スペースのインデントが好きでも、2スペースインデントコードの中ではそう**しないでください**。また、ファイル全体のインデント修正もしないでください。大量の無意味な差分を生んでしまいます。

<!--
Indent Code Consistently
^^^^^^^^^^^^^^^^^^^^^^^^

Okay, in your first year of programming you were told that indentation is
important. If you didn't believe and internalize this then, now is the time.
Just do it. With the introduction of C++11, there are some new formatting
challenges that merit some suggestions to help have consistent, maintainable,
and tool-friendly formatting and indentation.
-->

#### インデントの一貫

C++11の導入に際し、一貫性・保守性・ツールフレンドリーなフォーマットとインデントを実現するために、いくつか提案があります。
コードブロックのための標準的なインデントは、2スペースです。

<!--
Format Lambdas Like Blocks Of Code
""""""""""""""""""""""""""""""""""

When formatting a multi-line lambda, format it like a block of code, that's
what it is. If there is only one multi-line lambda in a statement, and there
are no expressions lexically after it in the statement, drop the indent to the
standard two space indent for a block of code, as if it were an if-block opened
by the preceding part of the statement:

.. code-block:: c++

  std::sort(foo.begin(), foo.end(), [&](Foo a, Foo b) -> bool {
    if (a.blah < b.blah)
      return true;
    if (a.baz < b.baz)
      return true;
    return a.bam < b.bam;
  });
-->

##### ラムダはコードブロックと同様に整形

複数行のラムダを整形する際は、コードブロックと同様に整形してください。もし文中に複数行のラムダしかなく、その後に式もない場合、ifブロック同様にインデントを下げます。

```cpp
std::sort(foo.begin(), foo.end(), [&](Foo a, Foo b) -> bool {
  if (a.blah < b.blah)
    return true;
  if (a.baz < b.baz)
    return true;
  return a.bam < b.bam;
});
```

<!--
To take best advantage of this formatting, if you are designing an API which
accepts a continuation or single callable argument (be it a functor, or
a ``std::function``), it should be the last argument if at all possible.

If there are multiple multi-line lambdas in a statement, or there is anything
interesting after the lambda in the statement, indent the block two spaces from
the indent of the ``[]``:
-->

このフォーマットを活かすため、新規APIで継続や単一の呼び出し可能な引数（ファンクタや`std::function`）をとる場合、なるべく最後の引数にします。

文の中にいくつも複数行のラムダがあったり、ラムダの後ろに何かが続く場合には、`[]`から2スペースインデントします。

<!--
.. code-block:: c++

  dyn_switch(V->stripPointerCasts(),
             [] (PHINode *PN) {
               // process phis...
             },
             [] (SelectInst *SI) {
               // process selects...
             },
             [] (LoadInst *LI) {
               // process loads...
             },
             [] (AllocaInst *AI) {
               // process allocas...
             });
-->

```cpp
dyn_switch(V->stripPointerCasts(),
           [] (PHINode *PN) {
             // process phis...
           },
           [] (SelectInst *SI) {
             // process selects...
           },
           [] (LoadInst *LI) {
             // process loads...
           },
           [] (AllocaInst *AI) {
             // process allocas...
           });
```

<!--
Braced Initializer Lists
""""""""""""""""""""""""

With C++11, there are significantly more uses of braced lists to perform
initialization. These allow you to easily construct aggregate temporaries in
expressions among other niceness. They now have a natural way of ending up
nested within each other and within function calls in order to build up
aggregates (such as option structs) from local variables. To make matters
worse, we also have many more uses of braces in an expression context that are
*not* performing initialization.
-->

##### ブレース初期化子リスト

C++11では、初期化用のブレースリストにかなり多くの用途があります。これらは簡単に式内で一時的な生成ができます。今ではこれらは、入れ子になったり、関数呼び出し内でローカル変数からのまとめ（オプション構造体等）を生成したりできます。さらに悪いことに、初期化が実行されて*いない*式中でもまた多様な使い道があります。

<!--
The historically common formatting of braced initialization of aggregate
variables does not mix cleanly with deep nesting, general expression contexts,
function arguments, and lambdas. We suggest new code use a simple rule for
formatting braced initialization lists: act as-if the braces were parentheses
in a function call. The formatting rules exactly match those already well
understood for formatting nested function calls. Examples:

.. code-block:: c++

  foo({a, b, c}, {1, 2, 3});

  llvm::Constant *Mask[] = {
      llvm::ConstantInt::get(llvm::Type::getInt32Ty(getLLVMContext()), 0),
      llvm::ConstantInt::get(llvm::Type::getInt32Ty(getLLVMContext()), 1),
      llvm::ConstantInt::get(llvm::Type::getInt32Ty(getLLVMContext()), 2)};

This formatting scheme also makes it particularly easy to get predictable,
consistent, and automatic formatting with tools like `Clang Format`_.

.. _Clang Format: http://clang.llvm.org/docs/ClangFormat.html
-->

変数をまとめて初期化するブレースの歴史的な共通フォーマットは、深いネスト、一般的な式中、関数引数、およびラムダときれいに混在できません。私たちは、新しいコードでブレース初期化リストの簡単な規則を用いることを提案します。関数呼び出し内のブレースは通常のかっこと同様に扱います。このフォーマット規則は、すでによく知られたネストされた関数呼び出しのフォーマットとうまく整合します。

```cpp:例
foo({a, b, c}, {1, 2, 3});

llvm::Constant *Mask[] = {
    llvm::ConstantInt::get(llvm::Type::getInt32Ty(getLLVMContext()), 0),
    llvm::ConstantInt::get(llvm::Type::getInt32Ty(getLLVMContext()), 1),
    llvm::ConstantInt::get(llvm::Type::getInt32Ty(getLLVMContext()), 2)};
```

このフォーマット方式は、適用が簡単で、一貫性があり、[Clang Format](http://clang.llvm.org/docs/ClangFormat.html)のようなツールで自動整形できます。

<!--

Language and Compiler Issues
----------------------------

Treat Compiler Warnings Like Errors
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If your code has compiler warnings in it, something is wrong --- you aren't
casting values correctly, you have "questionable" constructs in your code, or
you are doing something legitimately wrong.  Compiler warnings can cover up
legitimate errors in output and make dealing with a translation unit difficult.
-->

### 言語とコンパイラの問題

#### コンパイラ警告はエラーと同様に扱う

あなたのコードでコンパイラが警告を出す場合は、何かが間違っています。正確にキャストしていない、「疑わしい」生成、または何か合法的な誤りを犯しています。コンパイラ警告の指摘するコードは問題を覆い隠し、翻訳単位を扱いづらくする可能性があります。

<!--
It is not possible to prevent all warnings from all compilers, nor is it
desirable.  Instead, pick a standard compiler (like ``gcc``) that provides a
good thorough set of warnings, and stick to it.  At least in the case of
``gcc``, it is possible to work around any spurious errors by changing the
syntax of the code slightly.  For example, a warning that annoys me occurs when
I write code like this:

.. code-block:: c++

  if (V = getValue()) {
    ...
  }
-->

すべてのコンパイラ上ですべての警告を防ぐことは現実的でありません。代わりに、良い徹底した警告セットを提供する標準的なコンパイラ（`gcc`など）を選択し、それに固執してください。少なくとも`gcc`の場合には、若干のコードの構文を変更するだけで、偽の警告を回避できます。例えば、このようなコードを書く場合に悩ましい警告が出ます。

```cpp
if (V = getValue()) {
  ...
}
```

<!--
``gcc`` will warn me that I probably want to use the ``==`` operator, and that I
probably mistyped it.  In most cases, I haven't, and I really don't want the
spurious errors.  To fix this particular problem, I rewrite the code like
this:

.. code-block:: c++

  if ((V = getValue())) {
    ...
  }

which shuts ``gcc`` up.  Any ``gcc`` warning that annoys you can be fixed by
massaging the code appropriately.
-->

`gcc`は、`==`演算子のタイプミスの疑いを警告します。ほとんどの場合はそうでなく、偽のエラーを抑制したいです。この場合の解決としては、コードをこのように書き換えます。

```cpp
if ((V = getValue())) {
  ...
}
```

これで`gcc`は黙ります。あなたを悩ます任意の`gcc`警告は、コードを適切に整えることで修正できます。

<!--
Write Portable Code
^^^^^^^^^^^^^^^^^^^

In almost all cases, it is possible and within reason to write completely
portable code.  If there are cases where it isn't possible to write portable
code, isolate it behind a well defined (and well documented) interface.

In practice, this means that you shouldn't assume much about the host compiler
(and Visual Studio tends to be the lowest common denominator).  If advanced
features are used, they should only be an implementation detail of a library
which has a simple exposed API, and preferably be buried in ``libSystem``.
-->

#### 移植可能なコードを書く

ほとんどの場合、完全に移植可能なコードを書けます。不可能な場合は、明確に定義された（そしてきちんと文書化された）インタフェースの背後に隔離します。

これはあなたがホストコンパイラについて多くを期待してはならないことを意味します（そしてVisual Studioが最低基準となる傾向があります）。もしコンパイラ依存の高度な機能を使う場合、それらはシンプルな外部APIを持つライブラリの詳細実装であるべきです。`libSystem`内に埋め込まれることが望ましいです。

<!--
Do not use RTTI or Exceptions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In an effort to reduce code and executable size, LLVM does not use RTTI
(e.g. ``dynamic_cast<>;``) or exceptions.  These two language features violate
the general C++ principle of *"you only pay for what you use"*, causing
executable bloat even if exceptions are never used in the code base, or if RTTI
is never used for a class.  Because of this, we turn them off globally in the
code.

That said, LLVM does make extensive use of a hand-rolled form of RTTI that use
templates like :ref:`isa\<>, cast\<>, and dyn_cast\<> <isa>`.
This form of RTTI is opt-in and can be
:doc:`added to any class <HowToSetUpLLVMStyleRTTI>`. It is also
substantially more efficient than ``dynamic_cast<>``.
-->

#### RTTIや例外を使わない

コードと実行ファイルのサイズを減らすために、LLVMはRTTI（例えば`dynamic_cast<>`）や例外を使いません。これら2つの言語機能は、一般的なC++の **「従量課金」** 原則に反して実行ファイルの膨張を引き起こします。たとえ例外がコードで使われなかったり、RTTIがクラスで使われなかったとしてもです。このため、私たちはコード全体でそれらを無効にします。

LLVMはRTTIを手で展開した[isa<>、cast<>、そしてdyn_cast<>](http://releases.llvm.org/6.0.0/docs/ProgrammersManual.html#isa) のようなテンプレートを広く用います。RTTIのこの形式は、[任意のクラス](http://releases.llvm.org/6.0.0/docs/HowToSetUpLLVMStyleRTTI.html)にオプトインで追加できます。これらはおおむね`dynamic_cast<>`よりも効率的です。

<!--
.. _static constructor:
Do not use Static Constructors
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Static constructors and destructors (e.g. global variables whose types have a
constructor or destructor) should not be added to the code base, and should be
removed wherever possible.  Besides `well known problems
<http://yosefk.com/c++fqa/ctors.html#fqa-10.12>`_ where the order of
initialization is undefined between globals in different source files, the
entire concept of static constructors is at odds with the common use case of
LLVM as a library linked into a larger application.

Consider the use of LLVM as a JIT linked into another application (perhaps for
`OpenGL, custom languages <http://llvm.org/Users.html>`_, `shaders in movies
<http://llvm.org/devmtg/2010-11/Gritz-OpenShadingLang.pdf>`_, etc). Due to the
design of static constructors, they must be executed at startup time of the
entire application, regardless of whether or how LLVM is used in that larger
application.
-->

#### 静的コンストラクタを使わない

静的コンストラクタとデストラクタ（例えば、コンストラクタやデストラクタを持つ型のグローバル変数）はコードベースに追加されるべきではなく、可能な限り除かなければなりません。ソースファイル間での初期化順が未定義であるという[よく知られた問題](http://yosefk.com/c++fqa/ctors.html#fqa-10.12)もあります。静的コンストラクタの全体コンセプトは、大規模なアプリケーションにライブラリとしてリンクされるLLVMの一般的な使われ方と合いません。

別のアプリケーション（[OpenGL, custom languages](http://llvm.org/Users.html), [shaders in movies](http://llvm.org/devmtg/2010-11/Gritz-OpenShadingLang.pdf), 等）でJIT用にLLVMがリンクされた場合を考えてみましょう。静的コンストラクタの設計に起因して、LLVMがいつ使われるかに関わらず、それらはアプリケーションの起動時に実行されるでしょう。これには2つの問題があります。

<!--
There are two problems with this:

* The time to run the static constructors impacts startup time of applications
  --- a critical time for GUI apps, among others.

* The static constructors cause the app to pull many extra pages of memory off
  the disk: both the code for the constructor in each ``.o`` file and the small
  amount of data that gets touched. In addition, touched/dirty pages put more
  pressure on the VM system on low-memory machines.

We would really like for there to be zero cost for linking in an additional LLVM
target or other library into an application, but static constructors violate
this goal.

That said, LLVM unfortunately does contain static constructors.  It would be a
`great project <http://llvm.org/PR11944>`_ for someone to purge all static
constructors from LLVM, and then enable the ``-Wglobal-constructors`` warning
flag (when building with Clang) to ensure we do not regress in the future.
-->

- 静的コンストラクタの処理時間がアプリケーションの起動時間に影響します。特にGUIアプリケーションでは致命的な時間です。
- 静的コンストラクタにより、アプリが多くの余分なページメモリをディスクから引き出します。各`.o`ファイル内のコンストラクタコードと僅かなデータ。また、touched/dirtyページは低メモリマシン上のVMにさらなる負担を加えます。

私たちは、追加のLLVMターゲットやアプリケーションのライブラリへのリンクがゼロコストであることを強く望みますが、静的コンストラクタはこの目標に反します。

とはいえ、LLVMは残念ながら静的コンストラクタを含んでいます。[great project](http://llvm.org/PR11944)にてLLVMからすべての静的コンストラクタが取り除こうとしています。達成の暁には将来退行しないように`-Wglobal-constructors`警告フラグ（Clangビルドの場合）を有効にします。

<!--
Use of ``class`` and ``struct`` Keywords
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In C++, the ``class`` and ``struct`` keywords can be used almost
interchangeably. The only difference is when they are used to declare a class:
``class`` makes all members private by default while ``struct`` makes all
members public by default.

Unfortunately, not all compilers follow the rules and some will generate
different symbols based on whether ``class`` or ``struct`` was used to declare
the symbol (e.g., MSVC).  This can lead to problems at link time.
-->

#### `class`と`struct`キーワードの使い方

C++では、`class`と`struct`キーワードはほぼ同じ意味で使えます。唯一の違いはクラス宣言の場合です。`class`はデフォルトでメンバーがprivateですが、`struct`はpublicです。

残念ながら、一部のコンパイラは規則に従いません。定義に用いられたのが`class`か`struct`かにより、異なるシンボルを生成します（MSVCなど）。これは、リンク時に問題となり得ます。

<!--
* All declarations and definitions of a given ``class`` or ``struct`` must use
  the same keyword.  For example:

.. code-block:: c++

  class Foo;

  // Breaks mangling in MSVC.
  struct Foo { int Data; };
-->

- 宣言と定義では、同じキーワードを使う必要があります。`class`での宣言に対しては`class`での定義が必要です。`struct`でも同様です。

```cpp:例
class Foo;

// Breaks mangling in MSVC.
struct Foo { int Data; };
```

<!--
* As a rule of thumb, ``struct`` should be kept to structures where *all*
  members are declared public.

.. code-block:: c++

  // Foo feels like a class... this is strange.
  struct Foo {
  private:
    int Data;
  public:
    Foo() : Data(0) { }
    int getData() const { return Data; }
    void setData(int D) { Data = D; }
  };

  // Bar isn't POD, but it does look like a struct.
  struct Bar {
    int Data;
    Bar() : Data(0) { }
  };
-->

- 経験則として、`struct`は*すべての*メンバーがpublic宣言されている構造にのみ用いるべきです。

```cpp
// Foo feels like a class... this is strange.
struct Foo {
private:
  int Data;
public:
  Foo() : Data(0) { }
  int getData() const { return Data; }
  void setData(int D) { Data = D; }
};

// Bar isn't POD, but it does look like a struct.
struct Bar {
  int Data;
  Bar() : Data(0) { }
};
```

<!--
Do not use Braced Initializer Lists to Call a Constructor
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In C++11 there is a "generalized initialization syntax" which allows calling
constructors using braced initializer lists. Do not use these to call
constructors with any interesting logic or if you care that you're calling some
*particular* constructor. Those should look like function calls using
parentheses rather than like aggregate initialization. Similarly, if you need
to explicitly name the type and call its constructor to create a temporary,
don't use a braced initializer list. Instead, use a braced initializer list
(without any type for temporaries) when doing aggregate initialization or
something notionally equivalent.
-->

#### ブレース初期化子リストはコンストラクタ呼び出しに使わない

C++11ではブレース初期化子リストを使ってコンストラクタを呼べる「一般初期化構文（generalized initialization syntax）」があります。ロジックを含むコンストラクタや*特定の*コンストラクタを呼び出さなければいけない場合、これらを使わないでください。それらは集約初期化などではなく、むしろ括弧を使った関数呼び出しでしょう。同様に、名前の付いた型をその場で生成するためにコンストラクタを呼ぶ場合、ブレース初期化子リストを使わないでください。代わりに、集約等ではブレース初期化リスト（一時的な型を除く）を使います。

<!--
Examples:

.. code-block:: c++

  class Foo {
  public:
    // Construct a Foo by reading data from the disk in the whizbang format, ...
    Foo(std::string filename);

    // Construct a Foo by looking up the Nth element of some global data ...
    Foo(int N);

    // ...
  };

  // The Foo constructor call is very deliberate, no braces.
  std::fill(foo.begin(), foo.end(), Foo("name"));

  // The pair is just being constructed like an aggregate, use braces.
  bar_map.insert({my_key, my_value});

If you use a braced initializer list when initializing a variable, use an equals before the open curly brace:

.. code-block:: c++

  int data[] = {0, 1, 2, 3};
-->

```cpp:例
class Foo {
public:
  // Construct a Foo by reading data from the disk in the whizbang format, ...
  Foo(std::string filename);

  // Construct a Foo by looking up the Nth element of some global data ...
  Foo(int N);

  // ...
};

// The Foo constructor call is very deliberate, no braces.
std::fill(foo.begin(), foo.end(), Foo("name"));

// The pair is just being constructed like an aggregate, use braces.
bar_map.insert({my_key, my_value});
```

変数の初期化でブレース初期化子リストを使う場合は、等号を使います。

```cpp
int data[] = {0, 1, 2, 3};
```

<!--
Use ``auto`` Type Deduction to Make Code More Readable
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Some are advocating a policy of "almost always ``auto``" in C++11, however LLVM
uses a more moderate stance. Use ``auto`` if and only if it makes the code more
readable or easier to maintain. Don't "almost always" use ``auto``, but do use
``auto`` with initializers like ``cast<Foo>(...)`` or other places where the
type is already obvious from the context. Another time when ``auto`` works well
for these purposes is when the type would have been abstracted away anyways,
often behind a container's typedef such as ``std::vector<T>::iterator``.
-->

#### コードを読みやすくするために`auto`型推論を使う

C++11では「だいたいいつも`auto`」という主張もありますが、LLVMはより緩やかなスタンスを使用しています。コードが読みやすくなったり、保守しやすくなる場合のみ`auto`を使ってください。`auto`を使うのに「だいたいいつも」とはしませんが、`cast<Foo>(...)`等の初期化や、その他文脈から明らかな場合は`auto`を使ってください。また、抽象化されすぎている型に対しても`auto`は有用です。`std::vector<T>::iterator`のようなコンテナクラス内の型定義は抽象化されすぎている型の典型例でしょう。

<!--
Beware unnecessary copies with ``auto``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The convenience of ``auto`` makes it easy to forget that its default behavior
is a copy.  Particularly in range-based ``for`` loops, careless copies are
expensive.

As a rule of thumb, use ``auto &`` unless you need to copy the result, and use
``auto *`` when copying pointers.
.. code-block:: c++

  // Typically there's no reason to copy.
  for (const auto &Val : Container) { observe(Val); }
  for (auto &Val : Container) { Val.change(); }

  // Remove the reference if you really want a new copy.
  for (auto Val : Container) { Val.change(); saveSomewhere(Val); }

  // Copy pointers, but make it clear that they're pointers.
  for (const auto *Ptr : Container) { observe(*Ptr); }
  for (auto *Ptr : Container) { Ptr->change(); }
-->

#### `auto`での不必要なコピーに注意

`auto`の利便性は、そのデフォルト動作がコピーであることをよく忘れさせます。特に範囲ベース`for`ループでは、不注意なコピーが高くつきます。

経験則として、結果のコピーが不要であれば`auto &`を使い、ポインタをコピーする場合は`auto *`を使います。

```cpp
// Typically there's no reason to copy.
for (const auto &Val : Container) { observe(Val); }
for (auto &Val : Container) { Val.change(); }

// Remove the reference if you really want a new copy.
for (auto Val : Container) { Val.change(); saveSomewhere(Val); }

// Copy pointers, but make it clear that they're pointers.
for (const auto *Ptr : Container) { observe(*Ptr); }
for (auto *Ptr : Container) { Ptr->change(); }
```

<!--
Beware of non-determinism due to ordering of pointers
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In general, there is no relative ordering among pointers. As a result,
when unordered containers like sets and maps are used with pointer keys
the iteration order is undefined. Hence, iterating such containers may
result in non-deterministic code generation. While the generated code
might not necessarily be "wrong code", this non-determinism might result
in unexpected runtime crashes or simply hard to reproduce bugs on the
customer side making it harder to debug and fix.

As a rule of thumb, in case an ordered result is expected, remember to
sort an unordered container before iteration. Or use ordered containers
like vector/MapVector/SetVector if you want to iterate pointer keys.
-->

#### ポインタ順序による非決定性に注意

一般に、ポインタ同士に順序はありません。その結果、setやmapのように順序のないコンテナで、キーにポインタが使われる場合、反復(iteration)順序は未定義です。したがって、そのようなコンテナの反復は結果として非決定的なコードが生成されます（訳注：実行毎に順序が変わりうる）。必ずしも「間違ったコード」とは限りませんが、予期しないクラッシュを招いたり、再現しないバグを生じるなどして、デバッグを難しくします。

経験則として、順序ある結果を期待する場合は、順序なしコンテナの反復前にはソートを欠かさないでください。それか、ポインタキーを反復したいならvector/MapVector/SetVectorのような順序付きコンテナを使います。

<!--

Style Issues
============

The High-Level Issues
---------------------

A Public Header File **is** a Module
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

C++ doesn't do too well in the modularity department.  There is no real
encapsulation or data hiding (unless you use expensive protocol classes), but it
is what we have to work with.  When you write a public header file (in the LLVM
source tree, they live in the top level "``include``" directory), you are
defining a module of functionality.

Ideally, modules should be completely independent of each other, and their
header files should only ``#include`` the absolute minimum number of headers
possible. A module is not just a class, a function, or a namespace: it's a
collection of these that defines an interface.  This interface may be several
functions, classes, or data structures, but the important issue is how they work
together.

In general, a module should be implemented by one or more ``.cpp`` files.  Each
of these ``.cpp`` files should include the header that defines their interface
first.  This ensures that all of the dependences of the module header have been
properly added to the module header itself, and are not implicit.  System
headers should be included after user headers for a translation unit.

.. _minimal list of #includes:
-->

## スタイルの問題

### 高位の問題

#### 公開ヘッダファイル **は** モジュール

あなたが公開ヘッダファイル（LLVMソースツリーでは、トップの「`include`」にいます）を書く場合、それは機能モジュールを定義しています。

理想的には、モジュールは互いに完全に独立し、そのヘッダファイルには必要最小限の`#include`のみが含まれるべきです。モジュールは、単なるクラス、関数、あるいは名前空間ではありません。それらの集合で、インタフェースを定義します。このインタフェースは、いくつかの関数やクラスまたはデータ構造であってもよいですが、重要な問題はそれらがどのように連携するかです。

一般的に、モジュールは1つ以上の`.cpp`ファイルによって実装されるべきです。これら `.cpp`の各ファイルは、最初にそのインタフェースの定義ヘッダをインクルードする必要があります。これにより、モジュールヘッダの依存すべてが適切にモジュールヘッダ自体に追加されていることが保証されます。システムヘッダは、翻訳単位のユーザヘッダの後にインクルードされるべきです。

<!--
``#include`` as Little as Possible
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

``#include`` hurts compile time performance.  Don't do it unless you have to,
especially in header files.

But wait! Sometimes you need to have the definition of a class to use it, or to
inherit from it.  In these cases go ahead and ``#include`` that header file.  Be
aware however that there are many cases where you don't need to have the full
definition of a class.  If you are using a pointer or reference to a class, you
don't need the header file.  If you are simply returning a class instance from a
prototyped function or method, you don't need it.  In fact, for most cases, you
simply don't need the definition of a class. And not ``#include``\ing speeds up
compilation.

It is easy to try to go too overboard on this recommendation, however.  You
**must** include all of the header files that you are using --- you can include
them either directly or indirectly through another header file.  To make sure
that you don't accidentally forget to include a header file in your module
header, make sure to include your module header **first** in the implementation
file (as mentioned above).  This way there won't be any hidden dependencies that
you'll find out about later.
-->

#### `#include`は最低限に

`#include`はコンパイル時間を損ないます。どうしても必要でない場合は行わないでください、特にヘッダファイルでは。

でもちょっと待って！　使ったり、継承したりするためにクラス定義が必要になることがあります。その場合はどうぞ`#include`してください。ですが、クラスの完全な定義が必要でない場合も多いことに注意してください。以下の場合、ヘッダファイルは不要です。

- クラスのポインタや参照を使うだけの場合
- 関数やメソッド宣言の戻り値で使うだけ（ヘッダにその関数定義を含まない）の場合

この勧めをやりすぎるのは簡単ですが、使っているヘッダファイルのすべてがインクルードされなくては**なりません**。直接または別のヘッダーファイルを介して間接的にそれらをインクルードできます。モジュールヘッダ内でのインクルード漏れを確認する方法があります。前述のように実装ファイルの**最初に**モジュールヘッダを含めるようにしてください。この方法により、隠れた依存関係がコンパイルエラーとなり発覚します。

<!--
Keep "Internal" Headers Private
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Many modules have a complex implementation that causes them to use more than one
implementation (``.cpp``) file.  It is often tempting to put the internal
communication interface (helper classes, extra functions, etc) in the public
module header file.  Don't do this!

If you really need to do something like this, put a private header file in the
same directory as the source files, and include it locally.  This ensures that
your private interface remains private and undisturbed by outsiders.

.. note::

    It's okay to put extra implementation methods in a public class itself. Just
    make them private (or protected) and all is well.

.. _early exits:
-->

#### 「内部」ヘッダは非公開

多くのモジュールは、複数の実装（`.cpp`）ファイルを使うことで複雑な実装を持っています。多くの場合、内部通信インタフェース（ヘルパークラス、余分な機能など）を公開モジュールヘッダファイルに置くことは魅力的です。でもやめて！

本当に必要な場合は、ソースファイルと同じディレクトリに非公開ヘッダファイルを置いて、それを内々でインクルードしてください。これは、非公開インタフェースが他者に乱されず非公開であることを保証します。

> **注**
>
> 追加の実装メソッドをpublicクラス自体に入れても構いません。private（またはprotected）とすることで、うまくいきます。

<!--
Use Early Exits and ``continue`` to Simplify Code
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When reading code, keep in mind how much state and how many previous decisions
have to be remembered by the reader to understand a block of code.  Aim to
reduce indentation where possible when it doesn't make it more difficult to
understand the code.  One great way to do this is by making use of early exits
and the ``continue`` keyword in long loops.  As an example of using an early
exit from a function, consider this "bad" code:

.. code-block:: c++

  Value *doSomething(Instruction *I) {
    if (!isa<TerminatorInst>(I) &&
        I->hasOneUse() && doOtherThing(I)) {
      ... some long code ....
    }

    return 0;
  }
-->

#### 早期終了と`continue`でコードをシンプルに

なるべくインデントを減らすことは、コードを理解しやすくします。1つの方法は、早期終了する（Early Exits）ことと、長いループで`continue`キーワードを使うことです。関数からの早期終了を使う例として、この「悪い」コードを考えてみます。

```cpp:悪い例
Value *doSomething(Instruction *I) {
  if (!isa<TerminatorInst>(I) &&
      I->hasOneUse() && doOtherThing(I)) {
    ... some long code ....
  }

  return 0;
}
```

<!--
This code has several problems if the body of the ``'if'`` is large.  When
you're looking at the top of the function, it isn't immediately clear that this
*only* does interesting things with non-terminator instructions, and only
applies to things with the other predicates.  Second, it is relatively difficult
to describe (in comments) why these predicates are important because the ``if``
statement makes it difficult to lay out the comments.  Third, when you're deep
within the body of the code, it is indented an extra level.  Finally, when
reading the top of the function, it isn't clear what the result is if the
predicate isn't true; you have to read to the end of the function to know that
it returns null.
-->

`'if'`の本文が大きい場合、このコードにはいくつか問題があります。第一に、関数の先頭を見ただけでは、条件に合わない場合何もしないことが分かりません。第二に、`if`文はコメントしづらいレイアウトのため、なぜそれら述部が重要であるかコメントすることは割合難しいです。第三に、コード本体の深いところでは、余分にインデントされます。最後に、関数の先頭を見ただけでは条件に合わない場合、戻り値が何であるかは明らかではありません。nullを返すことを知るためには、関数の最後まで読まなければなりません。

<!--
It is much preferred to format the code like this:

.. code-block:: c++

  Value *doSomething(Instruction *I) {
    // Terminators never need 'something' done to them because ...
    if (isa<TerminatorInst>(I))
      return 0;

    // We conservatively avoid transforming instructions with multiple uses
    // because goats like cheese.
    if (!I->hasOneUse())
      return 0;

    // This is really just here for example.
    if (!doOtherThing(I))
      return 0;

    ... some long code ....
  }
-->

```cpp:良い例
Value *doSomething(Instruction *I) {
  // Terminators never need 'something' done to them because ...
  if (isa<TerminatorInst>(I))
    return 0;

  // We conservatively avoid transforming instructions with multiple uses
  // because goats like cheese.
  if (!I->hasOneUse())
    return 0;

  // This is really just here for example.
  if (!doOtherThing(I))
    return 0;

  ... some long code ....
}
```

<!--
This fixes these problems.  A similar problem frequently happens in ``for``
loops.  A silly example is something like this:

.. code-block:: c++

  for (Instruction &I : BB) {
    if (auto *BO = dyn_cast<BinaryOperator>(&I)) {
      Value *LHS = BO->getOperand(0);
      Value *RHS = BO->getOperand(1);
      if (LHS != RHS) {
        ...
      }
    }
  }
-->

同様の問題は`for`ループで頻繁に起きます。愚かな例を示します。

```cpp:愚かな例
for (Instruction &I : BB) {
  if (auto *BO = dyn_cast<BinaryOperator>(&I)) {
    Value *LHS = BO->getOperand(0);
    Value *RHS = BO->getOperand(1);
    if (LHS != RHS) {
      ...
    }
  }
}
```

<!--
When you have very, very small loops, this sort of structure is fine. But if it
exceeds more than 10-15 lines, it becomes difficult for people to read and
understand at a glance. The problem with this sort of code is that it gets very
nested very quickly. Meaning that the reader of the code has to keep a lot of
context in their brain to remember what is going immediately on in the loop,
because they don't know if/when the ``if`` conditions will have ``else``\s etc.
It is strongly preferred to structure the loop like this:

.. code-block:: c++

  for (Instruction &I : BB) {
    auto *BO = dyn_cast<BinaryOperator>(&I);
    if (!BO) continue;

    Value *LHS = BO->getOperand(0);
    Value *RHS = BO->getOperand(1);
    if (LHS == RHS) continue;

    ...
  }
-->

非常に小さなループでは、この構造の問題はありません。10〜15行を超えた場合、一目で理解することは困難になります。この種のコードの問題は、あっという間にネストされてしまうことです。それはコードの読み手は、ループ内で何が行われているか把握するために、非常に多くのコンテキストを覚えておかなくてはならないことを意味します。なぜなら、彼らは`if`条件に`else`等があるかどうかを知りません。次のようなループを構成することが望ましいです。

```cpp:良い例
for (Instruction &I : BB) {
  auto *BO = dyn_cast<BinaryOperator>(&I);
  if (!BO) continue;

  Value *LHS = BO->getOperand(0);
  Value *RHS = BO->getOperand(1);
  if (LHS == RHS) continue;

  ...
}
```

<!--
This has all the benefits of using early exits for functions: it reduces nesting
of the loop, it makes it easier to describe why the conditions are true, and it
makes it obvious to the reader that there is no ``else`` coming up that they
have to push context into their brain for.  If a loop is large, this can be a
big understandability win.
-->

これには、関数の早期終了を使う利点が全て備わっています。ループのネストを減らし、条件に該当する理由を簡単に記述でき、そして`else`を気にしなくてよいことが明らかです。ループが大きい場合、非常に分かりやすくなります。

<!--
Don't use ``else`` after a ``return``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For similar reasons above (reduction of indentation and easier reading), please
do not use ``'else'`` or ``'else if'`` after something that interrupts control
flow --- like ``return``, ``break``, ``continue``, ``goto``, etc. For
example, this is *bad*:

.. code-block:: c++

  case 'J': {
    if (Signed) {
      Type = Context.getsigjmp_bufType();
      if (Type.isNull()) {
        Error = ASTContext::GE_Missing_sigjmp_buf;
        return QualType();
      } else {
        break;
      }
    } else {
      Type = Context.getjmp_bufType();
      if (Type.isNull()) {
        Error = ASTContext::GE_Missing_jmp_buf;
        return QualType();
      } else {
        break;
      }
    }
  }
-->

#### `return`後に`else`を使用しない

上記と同様の理由（インデントの減少と読みやすさ）から、制御フローの中断後に`else`や`else if`を使わないでください。制御フローの中断とは`return`、`break`、`continue`、`goto`等です。*悪い*例を示します。

```cpp:悪い例
case 'J': {
  if (Signed) {
    Type = Context.getsigjmp_bufType();
    if (Type.isNull()) {
      Error = ASTContext::GE_Missing_sigjmp_buf;
      return QualType();
    } else {
      break;
    }
  } else {
    Type = Context.getjmp_bufType();
    if (Type.isNull()) {
      Error = ASTContext::GE_Missing_jmp_buf;
      return QualType();
    } else {
      break;
    }
  }
}
```

<!--
It is better to write it like this:

.. code-block:: c++

  case 'J':
    if (Signed) {
      Type = Context.getsigjmp_bufType();
      if (Type.isNull()) {
        Error = ASTContext::GE_Missing_sigjmp_buf;
        return QualType();
      }
    } else {
      Type = Context.getjmp_bufType();
      if (Type.isNull()) {
        Error = ASTContext::GE_Missing_jmp_buf;
        return QualType();
      }
    }
    break;
-->

次のように書く方が良いです。

```cpp:好ましい例
case 'J':
  if (Signed) {
    Type = Context.getsigjmp_bufType();
    if (Type.isNull()) {
      Error = ASTContext::GE_Missing_sigjmp_buf;
      return QualType();
    }
  } else {
    Type = Context.getjmp_bufType();
    if (Type.isNull()) {
      Error = ASTContext::GE_Missing_jmp_buf;
      return QualType();
    }
  }
  break;
```

<!--
Or better yet (in this case) as:

.. code-block:: c++

  case 'J':
    if (Signed)
      Type = Context.getsigjmp_bufType();
    else
      Type = Context.getjmp_bufType();

    if (Type.isNull()) {
      Error = Signed ? ASTContext::GE_Missing_sigjmp_buf :
                       ASTContext::GE_Missing_jmp_buf;
      return QualType();
    }
    break;

The idea is to reduce indentation and the amount of code you have to keep track
of when reading the code.
-->

またはいっそのこと。

```cpp:思い切った例
case 'J':
  if (Signed)
    Type = Context.getsigjmp_bufType();
  else
    Type = Context.getjmp_bufType();

  if (Type.isNull()) {
    Error = Signed ? ASTContext::GE_Missing_sigjmp_buf :
                     ASTContext::GE_Missing_jmp_buf;
    return QualType();
  }
  break;
```

この案はインデントと、コードを読み取るときに覚えておかなくてはならないコードの量を減らします。

<!--
Turn Predicate Loops into Predicate Functions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

It is very common to write small loops that just compute a boolean value.  There
are a number of ways that people commonly write these, but an example of this
sort of thing is:

.. code-block:: c++

  bool FoundFoo = false;
  for (unsigned I = 0, E = BarList.size(); I != E; ++I)
    if (BarList[I]->isFoo()) {
      FoundFoo = true;
      break;
    }

  if (FoundFoo) {
    ...
  }
-->

#### Predicateはループから関数へ

成否判定だけの小さなループを書くことは非常に一般的です。これを書く方法は様々ありますが、例えば次のようなものです。

```cpp:例
bool FoundFoo = false;
for (unsigned I = 0, E = BarList.size(); I != E; ++I)
  if (BarList[I]->isFoo()) {
    FoundFoo = true;
    break;
  }

if (FoundFoo) {
  ...
}
```

<!--
This sort of code is awkward to write, and is almost always a bad sign.  Instead
of this sort of loop, we strongly prefer to use a predicate function (which may
be `static`_) that uses `early exits`_ to compute the predicate.  We prefer the
code to be structured like this:

.. code-block:: c++

  /// \returns true if the specified list has an element that is a foo.
  static bool containsFoo(const std::vector<Bar*> &List) {
    for (unsigned I = 0, E = List.size(); I != E; ++I)
      if (List[I]->isFoo())
        return true;
    return false;
  }
  ...

  if (containsFoo(BarList)) {
    ...
  }
-->

この種のコードを書くのは厄介であり、大抵は悪い兆候です。関数化（staticにできます）し早期終了を使いましょう。次のようなコード構成が好ましいです。

```cpp:好ましい例
/// \returns true if the specified list has an element that is a foo.
static bool containsFoo(const std::vector<Bar*> &List) {
  for (unsigned I = 0, E = List.size(); I != E; ++I)
    if (List[I]->isFoo())
      return true;
  return false;
}
...

if (containsFoo(BarList)) {
  ...
}
```

<!--
There are many reasons for doing this: it reduces indentation and factors out
code which can often be shared by other code that checks for the same predicate.
More importantly, it *forces you to pick a name* for the function, and forces
you to write a comment for it.  In this silly example, this doesn't add much
value.  However, if the condition is complex, this can make it a lot easier for
the reader to understand the code that queries for this predicate.  Instead of
being faced with the in-line details of how we check to see if the BarList
contains a foo, we can trust the function name and continue reading with better
locality.
-->

これを行うには多くの理由があります。インデントを減らし、しばしば共有できる同じチェックを行う他のコードとの重複を排除します。さらに重要なのは、関数の*命名を強制*し、それにコメントを書くことを強制します。このちっぽけな例では、大した価値がありません。ですが条件が複雑な場合は、predicateクエリをより簡単に理解できるようになるでしょう。インラインで詳細にBarListがfooを含むかをどのようにチェックするのかについて直面するのではなく、関数名を信頼しより良い局所性で読んでいけます。

<!--

The Low-Level Issues
--------------------

Name Types, Functions, Variables, and Enumerators Properly
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Poorly-chosen names can mislead the reader and cause bugs. We cannot stress
enough how important it is to use *descriptive* names.  Pick names that match
the semantics and role of the underlying entities, within reason.  Avoid
abbreviations unless they are well known.  After picking a good name, make sure
to use consistent capitalization for the name, as inconsistency requires clients
to either memorize the APIs or to look it up to find the exact spelling.
In general, names should be in camel case (e.g. ``TextFileReader`` and
``isLValue()``).  Different kinds of declarations have different rules:
-->

### 低位の問題

#### 型、関数、変数、および列挙子への適切な命名

下手に選ばれた名前は、読者に誤解を与え、バグを引き起こす可能性があります。私たちは、*わかりやすい*名前を使うことがどれだけ重要か、とても十分に強調しきれません。常識の範囲で、要素の意味と役割に一致する名前を選んでください。よく知られていない限り略語は避けてください。良い名前を選んだ後、名前に一貫した大文字を使ってください。ブレがあると、利用者はいちいち細かいつづりに煩わされます。

一般に、名前はキャメルケース（例：`TextFileReader`と`isLValue()`）でなければなりません。種類ごとにルールがあります。

<!--
* **Type names** (including classes, structs, enums, typedefs, etc) should be
  nouns and start with an upper-case letter (e.g. ``TextFileReader``).

* **Variable names** should be nouns (as they represent state).  The name should
  be camel case, and start with an upper case letter (e.g. ``Leader`` or
  ``Boats``).

* **Function names** should be verb phrases (as they represent actions), and
  command-like function should be imperative.  The name should be camel case,
  and start with a lower case letter (e.g. ``openFile()`` or ``isFoo()``).

* **Enum declarations** (e.g. ``enum Foo {...}``) are types, so they should
  follow the naming conventions for types.  A common use for enums is as a
  discriminator for a union, or an indicator of a subclass.  When an enum is
  used for something like this, it should have a ``Kind`` suffix
  (e.g. ``ValueKind``).

* **Enumerators** (e.g. ``enum { Foo, Bar }``) and **public member variables**
  should start with an upper-case letter, just like types.  Unless the
  enumerators are defined in their own small namespace or inside a class,
  enumerators should have a prefix corresponding to the enum declaration name.
  For example, ``enum ValueKind { ... };`` may contain enumerators like
  ``VK_Argument``, ``VK_BasicBlock``, etc.  Enumerators that are just
  convenience constants are exempt from the requirement for a prefix.  For
  instance:

  .. code-block:: c++

      enum {
        MaxSize = 42,
        Density = 12
      };
-->

- **型名**（クラス、構造体、列挙型、typedef等を含む）は、名詞かつ大文字で始めます（例：`TextFileReader`）。
- **変数名**は（状態を代表するような）名詞とします。名前はキャメルケースで、大文字で始めます（例：`Leader`や`Boats`）。
- **関数名**は（アクション表すような）動詞であるべきで、コマンドのような関数は命令型とします。名前はキャメルケースで、小文字で始めます（例：`openFile()`や`isFoo()`）。
- **列挙型宣言**（例： `enum Foo {...}`）は型のため、型名の規則に準じます。列挙型は一般に、共用体（union）の弁別や、サブクラスの情報提供のために使います。列挙型は、このような何かのために使われる場合、`Kind`で終わります（例：`ValueKind`）。
- **列挙子**（例：`enum { Foo, Bar }`）と**パブリックメンバー変数**は、型と同様に大文字で始めます。列挙子は、小さな名前空間内やクラス内で定義されていない限り、列挙型の宣言名に対応する接頭辞を持ちます。たとえば、`enum ValueKind { ...};`は`VK_Argument`、`VK_BasicBlock`といったような列挙子を含むでしょう。便利な定数としての列挙子は、接頭辞の要件が免除されます。

```cpp:定数列挙子の例
enum {
  MaxSize = 42,
  Density = 12
};
```

<!--
As an exception, classes that mimic STL classes can have member names in STL's
style of lower-case words separated by underscores (e.g. ``begin()``,
``push_back()``, and ``empty()``). Classes that provide multiple
iterators should add a singular prefix to ``begin()`` and ``end()``
(e.g. ``global_begin()`` and ``use_begin()``).

Here are some examples of good and bad names:

.. code-block:: c++

  class VehicleMaker {
    ...
    Factory<Tire> F;            // Bad -- abbreviation and non-descriptive.
    Factory<Tire> Factory;      // Better.
    Factory<Tire> TireFactory;  // Even better -- if VehicleMaker has more than one
                                // kind of factories.
  };

  Vehicle makeVehicle(VehicleType Type) {
    VehicleMaker M;                         // Might be OK if having a short life-span.
    Tire Tmp1 = M.makeTire();               // Bad -- 'Tmp1' provides no information.
    Light Headlight = M.makeLight("head");  // Good -- descriptive.
    ...
  }
-->

例外として、STLクラスを模倣するクラスがあります。このクラスは、アンダースコアで区切られた小文字の単語というSTLのスタイルでメンバー名を持てます（例：`begin()`、`push_back()`と`empty()`）。複数のイテレータを提供するクラスは`begin()`と`end()`に特異な接頭辞を追加する必要があります（例：`global_begin()`と `use_begin()`）。

```cpp:良い名前と悪い名前の例
class VehicleMaker {
  ...
  Factory<Tire> F;            // Bad -- abbreviation and non-descriptive.
  Factory<Tire> Factory;      // Better.
  Factory<Tire> TireFactory;  // Even better -- if VehicleMaker has more than one
                              // kind of factories.
};

Vehicle makeVehicle(VehicleType Type) {
  VehicleMaker M;                         // Might be OK if having a short life-span.
  Tire Tmp1 = M.makeTire();               // Bad -- 'Tmp1' provides no information.
  Light Headlight = M.makeLight("head");  // Good -- descriptive.
  ...
}
```

<!--
Assert Liberally
^^^^^^^^^^^^^^^^

Use the "``assert``" macro to its fullest.  Check all of your preconditions and
assumptions, you never know when a bug (not necessarily even yours) might be
caught early by an assertion, which reduces debugging time dramatically.  The
"``<cassert>``" header file is probably already included by the header files you
are using, so it doesn't cost anything to use it.

To further assist with debugging, make sure to put some kind of error message in
the assertion statement, which is printed if the assertion is tripped. This
helps the poor debugger make sense of why an assertion is being made and
enforced, and hopefully what to do about it.  Here is one complete example:

.. code-block:: c++

  inline Value *getOperand(unsigned I) {
    assert(I < Operands.size() && "getOperand() out of range!");
    return Operands[I];
  }
-->

#### たっぷりのアサート

「`assert`」マクロを最大限に使います。すべての前提条件と仮定をチェックすれば、バグ（あなたのものとは限りません）がアサーションによって早く発見できるとは限りませんが、デバッグ時間は劇的に減ります。「`<cassert>`」ヘッダファイルは、おそらくもうインクルードされているので、追加のコストはかからないでしょう。

さらに、デバッグを支援するために、アサーション文に何らかのエラーメッセージを入れてください。これは、アサーションの発生原因とそれについて何をすべきかを、未熟なデバッガが理解する助けとなります。

```cpp:一つの完全な例
inline Value *getOperand(unsigned I) {
  assert(I < Operands.size() && "getOperand() out of range!");
  return Operands[I];
}
```

<!--
Here are more examples:

.. code-block:: c++

  assert(Ty->isPointerType() && "Can't allocate a non-pointer type!");

  assert((Opcode == Shl || Opcode == Shr) && "ShiftInst Opcode invalid!");

  assert(idx < getNumSuccessors() && "Successor # out of range!");

  assert(V1.getType() == V2.getType() && "Constant types must be identical!");

  assert(isa<PHINode>(Succ->front()) && "Only works on PHId BBs!");
-->

```cpp:多くの例
assert(Ty->isPointerType() && "Can't allocate a non-pointer type!");
assert((Opcode == Shl || Opcode == Shr) && "ShiftInst Opcode invalid!");
assert(idx < getNumSuccessors() && "Successor # out of range!");
assert(V1.getType() == V2.getType() && "Constant types must be identical!");
assert(isa<PHINode>(Succ->front()) && "Only works on PHId BBs!");
```

<!--
You get the idea.

In the past, asserts were used to indicate a piece of code that should not be
reached.  These were typically of the form:

.. code-block:: c++

  assert(0 && "Invalid radix for integer literal");

This has a few issues, the main one being that some compilers might not
understand the assertion, or warn about a missing return in builds where
assertions are compiled out.

Today, we have something much better: ``llvm_unreachable``:

.. code-block:: c++

  llvm_unreachable("Invalid radix for integer literal");

When assertions are enabled, this will print the message if it's ever reached
and then exit the program. When assertions are disabled (i.e. in release
builds), ``llvm_unreachable`` becomes a hint to compilers to skip generating
code for this branch. If the compiler does not support this, it will fall back
to the "abort" implementation.
-->

過去には、コードに到達すべきではないと示すためにアサートが使われました。

```cpp:典型例
assert(0 && "Invalid radix for integer literal");
```

これにはいくつかの問題があります。主なものは、いくつかのコンパイラはアサーションを理解しない可能性があり、あるいはアサーションの部分でreturnが抜けていると警告を出すことです。

今日、私たちにはより良いものがあります。`llvm_unreachable`。

```cpp:好ましい例
llvm_unreachable("Invalid radix for integer literal");
```

アサーションを有効にすると、ここに到達した時点でメッセージを表示し、プログラムを終了します。アサーションが無効になっている場合（つまりリリースビルドでは）、`llvm_unreachable`はこの分岐のコード生成は省略可能だというコンパイラへのヒントとなります。コンパイラがこれをサポートしていない場合は、「abort」実装にフォールバックされます。

<!--
Neither assertions or ``llvm_unreachable`` will abort the program on a release
build. If the error condition can be triggered by user input then the
recoverable error mechanism described in :doc:`ProgrammersManual` should be
used instead. In cases where this is not practical, ``report_fatal_error`` may
be used.
-->

アサーションも``llvm_unreachable``も、リリースビルドではプログラムをabortしません。もしユーザの入力によりエラー状態となりうる場合、[LLVM Programmer’s Manual](http://releases.llvm.org/6.0.0/docs/ProgrammersManual.html)にある回復可能なエラーメカニズムを使う必要があります。それが実用的でないような場合は、``report_fatal_error``を使います。

<!--
Another issue is that values used only by assertions will produce an "unused
value" warning when assertions are disabled.  For example, this code will warn:

.. code-block:: c++

  unsigned Size = V.size();
  assert(Size > 42 && "Vector smaller than it should be");

  bool NewToSet = Myset.insert(Value);
  assert(NewToSet && "The value shouldn't be in the set yet");

These are two interesting different cases. In the first case, the call to
``V.size()`` is only useful for the assert, and we don't want it executed when
assertions are disabled.  Code like this should move the call into the assert
itself.  In the second case, the side effects of the call must happen whether
the assert is enabled or not.  In this case, the value should be cast to void to
disable the warning.  To be specific, it is preferred to write the code like
this:

.. code-block:: c++

  assert(V.size() > 42 && "Vector smaller than it should be");

  bool NewToSet = Myset.insert(Value); (void)NewToSet;
  assert(NewToSet && "The value shouldn't be in the set yet");
-->

別の問題は、アサーションが無効になっている場合に、アサーションによってのみ使用される値で「未使用値」という警告が生成されるということです。

```cpp:警告となる例
unsigned Size = V.size();
assert(Size > 42 && "Vector smaller than it should be");

bool NewToSet = Myset.insert(Value);
assert(NewToSet && "The value shouldn't be in the set yet");
```

2つの興味深い例があります。最初の例では、`V.size()`の呼び出しはアサートのためにのみ有用であり、アサーションが無効になっている場合に実行されたくありません。このようなコードは、アサート自体に呼び出しを移動する必要があります。次の例では、呼び出しの副作用はアサートが有効かどうかに関わらず起きなければなりません。この場合、警告を無効にするには値をvoidにキャストします。具体的には、このようなコードがよいでしょう。

```cpp:好ましい例
assert(V.size() > 42 && "Vector smaller than it should be");

bool NewToSet = Myset.insert(Value); (void)NewToSet;
assert(NewToSet && "The value shouldn't be in the set yet");
```

<!--
Do Not Use ``using namespace std``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In LLVM, we prefer to explicitly prefix all identifiers from the standard
namespace with an "``std::``" prefix, rather than rely on "using namespace
std;".

In header files, adding a ``'using namespace XXX'`` directive pollutes the
namespace of any source file that ``#include``\s the header.  This is clearly a
bad thing.

In implementation files (e.g. ``.cpp`` files), the rule is more of a stylistic
rule, but is still important.  Basically, using explicit namespace prefixes
makes the code **clearer**, because it is immediately obvious what facilities
are being used and where they are coming from. And **more portable**, because
namespace clashes cannot occur between LLVM code and other namespaces.  The
portability rule is important because different standard library implementations
expose different symbols (potentially ones they shouldn't), and future revisions
to the C++ standard will add more symbols to the ``std`` namespace.  As such, we
never use ``'using namespace std;'`` in LLVM.
-->

#### `using namespace std`を使わない

LLVMでは、標準名前空間のすべての識別子について、「`using namespace std;`」に頼るのではなく、「`std::`」接頭辞を明示することを好みます。

ヘッダファイルで、`'using namespace XXX'`ディレクティブを追加することはヘッダを`#include`するソースファイルの名前空間を汚染します。これは明らかに悪いことです。

実装ファイル（例えば`.cpp`ファイル）では、よりスタイルの問題ですが、それでも重要です。基本的に、明示的な名前空間の接頭辞は、コードを**明解**にします。また、LLVMコードや他の名前空間との間で名前空間の衝突が起きないため、**よりポータブル**になります。将来のC++標準の改訂では`std`名前空間へのシンボル追加もあるでしょう。ですので、私たちはLLVMで`'using namespace std;'`を決して使いません。

<!--
The exception to the general rule (i.e. it's not an exception for the ``std``
namespace) is for implementation files.  For example, all of the code in the
LLVM project implements code that lives in the 'llvm' namespace.  As such, it is
ok, and actually clearer, for the ``.cpp`` files to have a 'using namespace
llvm;'`` directive at the top, after the ``#include\s.  This reduces
indentation in the body of the file for source editors that indent based on
braces, and keeps the conceptual context cleaner.  The general form of this rule
is that any ``.cpp`` file that implements code in any namespace may use that
namespace (and its parents'), but should not use any others.
-->

一般的なルールの例外（つまり、`std`名前空間の例外ではありません）は、実装ファイルのためのものです。例えば、LLVMプロジェクト内のすべてのコードは、「llvm」名前空間内のコードを実装します。ですので、それはOKとします。実際明解ですし、`.cpp`ファイルは`#include`直後の先頭に`'using namespace llvm;'`ディレクティブがあります。これは、中括弧に基づいたインデントを行うソースエディタ向けに本文のインデントを減らし、概念的なコンテキストをきれいに保ちます。この規則を一般的に表すと、次のとおりです。

- 任意の名前空間内のコードを実装する任意の`.cpp`ファイルは、それの（そして親の）名前空間を`using`してもよい。
- その他の名前空間を`using`してはならない。

<!--
Provide a Virtual Method Anchor for Classes in Headers
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If a class is defined in a header file and has a vtable (either it has virtual
methods or it derives from classes with virtual methods), it must always have at
least one out-of-line virtual method in the class.  Without this, the compiler
will copy the vtable and RTTI into every ``.o`` file that ``#include``\s the
header, bloating ``.o`` file sizes and increasing link times.
-->

#### ヘッダ内クラスは仮想メソッドアンカーを提供する

クラスがヘッダファイル内で定義されvtableを持つ（仮想メソッドを持つか、そういったクラスから派生した）場合、仮想メソッドの少なくとも1つはout-of-line（.cppファイルで定義）します。これがないと、コンパイラは、そのヘッダを`#include`した`.o`ファイルすべてにvtableとRTTIをコピーし、`.o`ファイルサイズとリンク時間を増やします。これはClangの`-Wweak-vtables`警告で指摘されることがあります。

<!--
Don't use default labels in fully covered switches over enumerations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

``-Wswitch`` warns if a switch, without a default label, over an enumeration
does not cover every enumeration value. If you write a default label on a fully
covered switch over an enumeration then the ``-Wswitch`` warning won't fire
when new elements are added to that enumeration. To help avoid adding these
kinds of defaults, Clang has the warning ``-Wcovered-switch-default`` which is
off by default but turned on when building LLVM with a version of Clang that
supports the warning.

A knock-on effect of this stylistic requirement is that when building LLVM with
GCC you may get warnings related to "control may reach end of non-void function"
if you return from each case of a covered switch-over-enum because GCC assumes
that the enum expression may take any representable value, not just those of
individual enumerators. To suppress this warning, use ``llvm_unreachable`` after
the switch.
-->

#### 列挙型を網羅したswitchにdefaultを使わない

`-Wswitch`は、列挙型の値を網羅せず、defaultも無いswitchに警告を出します。列挙型を網羅したswitchにdefaultを書いた場合、新しい要素が列挙体に追加されても`-Wswitch`は警告しません。この種のdefaultを追加することを避けるために、Clangは`-Wcovered-switch-default`警告を持ちます。これはデフォルトで無効になっていますが、Clangの警告をサポートする版でLLVMをビルドする場合は有効になります。

この影響で、列挙型を網羅したswitchの各caseでreturnしていた場合、GCCでビルドすると「コントロールが非void型関数の終わりに到達します」関連の警告が出ます。GCCはenum句が個々の列挙子だけでなく任意の値を取れることを前提としているためです。この警告を抑止するには、switchの後に`llvm_unreachable`を使います。

<!--
Use range-based ``for`` loops wherever possible
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The introduction of range-based ``for`` loops in C++11 means that explicit
manipulation of iterators is rarely necessary. We use range-based ``for``
loops wherever possible for all newly added code. For example:

.. code-block:: c++

  BasicBlock *BB = ...
  for (Instruction &I : *BB)
    ... use I ...
-->

#### できるだけrange-based ``for``ループを使う

C++11でのrange-based ``for``ループの導入は、イテレータの明示的操作がめったに要らないことを意味します。私達は、すべての新規追加コードに対して、できるだけrange-based ``for``ループを使います。

```cpp
BasicBlock *BB = ...
for (Instruction &I : *BB)
  ... use I ...
```

<!--
Don't evaluate ``end()`` every time through a loop
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In cases where range-based ``for`` loops can't be used and it is necessary
to write an explicit iterator-based loop, pay close attention to whether
``end()`` is re-evaluted on each loop iteration. One common mistake is to
write a loop in this style:

.. code-block:: c++

  BasicBlock *BB = ...
  for (auto I = BB->begin(); I != BB->end(); ++I)
    ... use I ...
-->

#### ループで毎回`end()`を評価しない

range-based ``for``ループが使えず、イテレータを明示するループを書かざるを得ない場合、毎ループ``end()``が再評価されるかどうか細心の注意を払ってください。
よくある間違いは、このようなスタイルで書くことです。

```cpp:悪いループスタイル
BasicBlock *BB = ...
for (auto I = BB->begin(); I != BB->end(); ++I)
  ... use I ...
```

<!--
The problem with this construct is that it evaluates "``BB->end()``" every time
through the loop.  Instead of writing the loop like this, we strongly prefer
loops to be written so that they evaluate it once before the loop starts.  A
convenient way to do this is like so:

.. code-block:: c++

  BasicBlock *BB = ...
  for (auto I = BB->begin(), E = BB->end(); I != E; ++I)
    ... use I ...
-->

この構造の問題は、ループ毎に"``BB->end()``"が評価されてしまうことです。このようなループではなく、ループ前に一度だけ評価するような書き方を強くお勧めします。

```cpp:ループ前に一度だけ評価する便利な方法
BasicBlock *BB = ...
for (auto I = BB->begin(), E = BB->end(); I != E; ++I)
  ... use I ...
```

<!--
The observant may quickly point out that these two loops may have different
semantics: if the container (a basic block in this case) is being mutated, then
"``BB->end()``" may change its value every time through the loop and the second
loop may not in fact be correct.  If you actually do depend on this behavior,
please write the loop in the first form and add a comment indicating that you
did it intentionally.
-->

注意深い方は、これら２つのループが異なるセマンティクスを持つ可能性にお気づきかもしれません。もしコンテナ（この例ではBasicBlock)が変更されるとしたら、"``BB->end()``"はループ毎に変わるかもしれず、２つ目のループ(訳注：事前評価)は正しくないかもしれません。実際そのような挙動に依存している場合は、最初の形式でループを書き、「意図的に毎ループ評価している」旨コメント追加してください。

<!--
Why do we prefer the second form (when correct)?  Writing the loop in the first
form has two problems. First it may be less efficient than evaluating it at the
start of the loop.  In this case, the cost is probably minor --- a few extra
loads every time through the loop.  However, if the base expression is more
complex, then the cost can rise quickly.  I've seen loops where the end
expression was actually something like: "``SomeMap[X]->end()``" and map lookups
really aren't cheap.  By writing it in the second form consistently, you
eliminate the issue entirely and don't even have to think about it.
-->

なぜ２つ目の形式がよいのか（正しい場合）？　最初の形式でループを書くことには２つの問題があります。第一に、ループ開始時に評価する方法と比べ、非効率かもしれません。この例では、コストはおそらくわずかですが、ループ毎に少し余分な負荷があります。しかしもっと複雑な式になると、コストが急上昇するかもしれません。"``SomeMap[X]->end()``"のような式を見たことがあります。mapのルックアップは決して安くありません。２つ目の書き方を一貫することで、問題を完全に排除でき、考えずに済みます。

<!--
The second (even bigger) issue is that writing the loop in the first form hints
to the reader that the loop is mutating the container (a fact that a comment
would handily confirm!).  If you write the loop in the second form, it is
immediately obvious without even looking at the body of the loop that the
container isn't being modified, which makes it easier to read the code and
understand what it does.

While the second form of the loop is a few extra keystrokes, we do strongly
prefer it.
-->

さらに大きな第二の問題は、最初の形式で書くことはループ内でコンテナを変更していることを示すということです（コメントは簡単な確認という事実！）。２つ目の形式でループを書くと、コンテナが変更されないことがループ内を見ずとも分かります。

２つ目の形式でのループは余分なキータイプはありますが、強くおすすめします。

<!--
``#include <iostream>`` is Forbidden
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The use of ``#include <iostream>`` in library files is hereby **forbidden**,
because many common implementations transparently inject a `static constructor`_
into every translation unit that includes it.

Note that using the other stream headers (``<sstream>`` for example) is not
problematic in this regard --- just ``<iostream>``. However, ``raw_ostream``
provides various APIs that are better performing for almost every use than
``std::ostream`` style APIs.

.. note::

  New code should always use `raw_ostream`_ for writing, or the
  ``llvm::MemoryBuffer`` API for reading files.

.. _raw_ostream:
-->

#### `#include <iostream>`禁止

ライブラリファイルで`#include <iostream>`を使うことは**禁止**されています。なぜなら、多くの一般的な実装では、それを含むすべての変換単位に静的コンストラクタを透過的に注入するからです。

その他のストリームヘッダ（たとえば`<sstream>`）の使用はこの点で問題ないことに注意してください。`<iostream>`のみです。しかし、`raw_ostream`の提供する様々なAPIは、ほとんどすべての用途で`std::ostream`スタイルのAPIよりも優れたパフォーマンスを発揮します。

> ** 注 **
>
> 新規コードでは常に、ファイル読み込みに`llvm::MemoryBuffer`APIを、書き込みにraw_ostreamを使ってください。

<!--
Use ``raw_ostream``
^^^^^^^^^^^^^^^^^^^

LLVM includes a lightweight, simple, and efficient stream implementation in
``llvm/Support/raw_ostream.h``, which provides all of the common features of
``std::ostream``.  All new code should use ``raw_ostream`` instead of
``ostream``.

Unlike ``std::ostream``, ``raw_ostream`` is not a template and can be forward
declared as ``class raw_ostream``.  Public headers should generally not include
the ``raw_ostream`` header, but use forward declarations and constant references
to ``raw_ostream`` instances.
-->

#### `raw_ostream`を使う

LLVMは軽量で、シンプルで、かつ効率的なストリーム実装を`llvm/Support/raw_ostream.h`に持ちます。これは`std::ostream`の共通機能をすべて提供します。すべての新規コードで`ostream`ではなく`raw_ostream`を使ってください。

`std::ostream`と異なり、`raw_ostream`はテンプレートではありません。そのため`class raw_ostream`のように前方宣言できます。公開ヘッダには通常`raw_ostream`ヘッダを含めず、代わりに`raw_ostream`インスタンスへの前方宣言と定数参照を使います。

<!--
Avoid ``std::endl``
^^^^^^^^^^^^^^^^^^^

The ``std::endl`` modifier, when used with ``iostreams`` outputs a newline to
the output stream specified.  In addition to doing this, however, it also
flushes the output stream.  In other words, these are equivalent:

.. code-block:: c++

  std::cout << std::endl;
  std::cout << '\n' << std::flush;

Most of the time, you probably have no reason to flush the output stream, so
it's better to use a literal ``'\n'``.
-->

#### `std::endl`を避ける

`std::endl`修飾子は、`iostream`と共に使われ、指定の出力ストリームに改行を出力します。そして、出力ストリームをフラッシュします。言い換えると、以下は同等です。

```cpp
std::cout << std::endl;
std::cout << '\n' << std::flush;
```

ほとんどの場合、おそらく出力ストリームをフラッシュする理由はありません。`'\n'`リテラルを使うことをお勧めします。

<!--
Don't use ``inline`` when defining a function in a class definition
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A member function defined in a class definition is implicitly inline, so don't
put the ``inline`` keyword in this case.

Don't:

.. code-block:: c++

  class Foo {
  public:
    inline void bar() {
      // ...
    }
  };

Do:

.. code-block:: c++

  class Foo {
  public:
    void bar() {
      // ...
    }
  };
-->

#### クラス定義内の関数定義で`inline`を使わない

クラス定義内で定義されたメンバー関数は暗黙的にインラインであるため、`inline`キーワードを入れないでください。

```cpp:禁止
class Foo {
public:
  inline void bar() {
    // ...
  }
};
```

```cpp:推奨
class Foo {
public:
  void bar() {
    // ...
  }
};
```

<!--

Microscopic Details
-------------------

This section describes preferred low-level formatting guidelines along with
reasoning on why we prefer them.
-->

### 細かい話

このセクションでは、推奨する低レベルのフォーマットガイドラインを、私たちが好む理由と共に説明します。

<!--
Spaces Before Parentheses
^^^^^^^^^^^^^^^^^^^^^^^^^

We prefer to put a space before an open parenthesis only in control flow
statements, but not in normal function call expressions and function-like
macros.  For example, this is good:

.. code-block:: c++

  if (X) ...
  for (I = 0; I != 100; ++I) ...
  while (LLVMRocks) ...

  somefunc(42);
  assert(3 != 4 && "laws of math are failing me");

  A = foo(42, 92) + bar(X);

and this is bad:

.. code-block:: c++

  if(X) ...
  for(I = 0; I != 100; ++I) ...
  while(LLVMRocks) ...

  somefunc (42);
  assert (3 != 4 && "laws of math are failing me");

  A = foo (42, 92) + bar (X);
-->

#### 括弧の前にスペース

フロー制御文の開き括弧の前でのみスペースを入れます。普通の関数呼び出しや関数風マクロでは入れません。

```cpp:良い例
if (X) ...
for (I = 0; I != 100; ++I) ...
while (LLVMRocks) ...

somefunc(42);
assert(3 != 4 && "laws of math are failing me");

A = foo(42, 92) + bar(X);
```

```cpp:悪い例
if(X) ...
for(I = 0; I != 100; ++I) ...
while(LLVMRocks) ...

somefunc (42);
assert (3 != 4 && "laws of math are failing me");

A = foo (42, 92) + bar (X);
```

<!--
The reason for doing this is not completely arbitrary.  This style makes control
flow operators stand out more, and makes expressions flow better. The function
call operator binds very tightly as a postfix operator.  Putting a space after a
function name (as in the last example) makes it appear that the code might bind
the arguments of the left-hand-side of a binary operator with the argument list
of a function and the name of the right side.  More specifically, it is easy to
misread the "``A``" example as:

.. code-block:: c++

  A = foo ((42, 92) + bar) (X);

when skimming through the code.  By avoiding a space in a function, we avoid
this misinterpretation.
-->

このスタイルは、制御フロー演算子を目立たせ、式の流れを良くします。関数呼び出し演算子は、後置演算子として非常に強く結合します。関数名の後にスペースを置くこと（最後の例のように）は、関数の引数リストといっしょの二項演算子について、引数を左側に持ち名前を右側に持つ二項演算のように見えます。具体的には、次のように「`A`」を簡単に読み違えてしまいます。

```cpp:例
A = foo ((42, 92) + bar) (X);
```

関数でのスペースを避けることで、この誤解を避けられます。

<!--
Prefer Preincrement
^^^^^^^^^^^^^^^^^^^

Hard fast rule: Preincrement (``++X``) may be no slower than postincrement
(``X++``) and could very well be a lot faster than it.  Use preincrementation
whenever possible.

The semantics of postincrement include making a copy of the value being
incremented, returning it, and then preincrementing the "work value".  For
primitive types, this isn't a big deal. But for iterators, it can be a huge
issue (for example, some iterators contains stack and set objects in them...
copying an iterator could invoke the copy ctor's of these as well).  In general,
get in the habit of always using preincrement, and you won't have a problem.
-->

#### 前置インクリメントの選好

前置インクリメント（`++X'）は後置インクリメント（`X++`）よりも遅くなることはありません。むしろはるかに速くなる可能性があります。可能な限り前置インクリメントを使いましょう。

後置インクリメントは次の3つの内容を含みます。

1. インクリメントされる値のコピーを作成する
1. 「作業値」を前置インクリメントする
1. インクリメント前の値を返す

プリミティブ型の場合、これはたいした問題ではありません。しかしイテレータでは、大きな問題となる可能性があります。例えば、いくつかのイテレータはスタックを含み、それらにオブジェクトを設定します。イテレータをコピーすると、それらのコピーコンストラクタを呼ぶことにもなります。一般に、いつも前置インクリメントを使う習慣を身につれば、問題は起きません。

<!--
Namespace Indentation
^^^^^^^^^^^^^^^^^^^^^

In general, we strive to reduce indentation wherever possible.  This is useful
because we want code to `fit into 80 columns`_ without wrapping horribly, but
also because it makes it easier to understand the code. To facilitate this and
avoid some insanely deep nesting on occasion, don't indent namespaces. If it
helps readability, feel free to add a comment indicating what namespace is
being closed by a ``}``.  For example:

.. code-block:: c++

  namespace llvm {
  namespace knowledge {

  /// This class represents things that Smith can have an intimate
  /// understanding of and contains the data associated with it.
  class Grokable {
  ...
  public:
    explicit Grokable() { ... }
    virtual ~Grokable() = 0;

    ...

  };

  } // end namespace knowledge
  } // end namespace llvm
-->

#### 名前空間のインデント

大概、私たちは可能な限りインデントを減らすよう努力しています。これはコードをひどい折り返しなしに収めるためにも便利ですが、コードを簡単に分かりやすくすることにも便利です。これを促進するとともに、非常に深いネストの機会を避けるために、名前空間はインデントしません。読みやすくなる場合、`}`でどの名前空間が閉じられるかをコメントしてもよいでしょう。

```cpp:例
namespace llvm {
namespace knowledge {

/// This class represents things that Smith can have an intimate
/// understanding of and contains the data associated with it.
class Grokable {
...
public:
  explicit Grokable() { ... }
  virtual ~Grokable() = 0;

  ...

};

} // end namespace knowledge
} // end namespace llvm
```

<!--
Feel free to skip the closing comment when the namespace being closed is
obvious for any reason. For example, the outer-most namespace in a header file
is rarely a source of confusion. But namespaces both anonymous and named in
source files that are being closed half way through the file probably could use
clarification.

.. _static:
-->

閉じられる名前空間が自明であれば終了コメントを省いてもよいでしょう。例えば、ヘッダファイル内の最も外側の名前空間はまず混乱の原因となりません。しかし、ソースファイルの途中で名前空間（名前の有無を問わず）を閉じる場合は、説明したほうがよいでしょう。

<!--
Anonymous Namespaces
^^^^^^^^^^^^^^^^^^^^

After talking about namespaces in general, you may be wondering about anonymous
namespaces in particular.  Anonymous namespaces are a great language feature
that tells the C++ compiler that the contents of the namespace are only visible
within the current translation unit, allowing more aggressive optimization and
eliminating the possibility of symbol name collisions.  Anonymous namespaces are
to C++ as "static" is to C functions and global variables.  While "``static``"
is available in C++, anonymous namespaces are more general: they can make entire
classes private to a file.

The problem with anonymous namespaces is that they naturally want to encourage
indentation of their body, and they reduce locality of reference: if you see a
random function definition in a C++ file, it is easy to see if it is marked
static, but seeing if it is in an anonymous namespace requires scanning a big
chunk of the file.
-->

#### 無名名前空間

一般的に名前空間の話をした後は、特に無名名前空間について気になるでしょう。無名名前空間は偉大な言語機能です。名前空間の内容が現在の翻訳単位でのみでしか見えないことをC++コンパイラに伝え、より積極的な最適化を可能にし、シンボル名の衝突の可能性を排除します。C++の無名名前空間は、Cの関数とグローバル変数での「static」に似ています。C++でも「`static`」は使えますが、無名名前空間のほうが一般的です。これはファイルに対してクラス全体を非公開にできます。

無名名前空間の問題は、本来的に本文のインデントを求めることと、参照の局所性を減らすことです。C++ファイルのrandom関数の定義を見る場合、それがstaticかどうかは簡単に分かります。無名名前空間にあるかどうかを知るには、ファイル全体を調べる必要があります。

<!--
Because of this, we have a simple guideline: make anonymous namespaces as small
as possible, and only use them for class declarations.  For example, this is
good:

.. code-block:: c++

  namespace {
  class StringSort {
  ...
  public:
    StringSort(...)
    bool operator<(const char *RHS) const;
  };
  } // end anonymous namespace

  static void runHelper() {
    ...
  }

  bool StringSort::operator<(const char *RHS) const {
    ...
  }
-->

このため、シンプルなガイドラインがあります。無名名前空間はできるだけ小さくし、クラス定義にのみ使います。

```cpp:OK
namespace {
class StringSort {
...
public:
  StringSort(...)
  bool operator<(const char *RHS) const;
};
} // end anonymous namespace

static void runHelper() {
  ...
}

bool StringSort::operator<(const char *RHS) const {
  ...
}
```

<!--
This is bad:

.. code-block:: c++

  namespace {

  class StringSort {
  ...
  public:
    StringSort(...)
    bool operator<(const char *RHS) const;
  };

  void runHelper() {
    ...
  }

  bool StringSort::operator<(const char *RHS) const {
    ...
  }

  } // end anonymous namespace
-->

```cpp:NG
namespace {

class StringSort {
...
public:
  StringSort(...)
  bool operator<(const char *RHS) const;
};

void runHelper() {
  ...
}

bool StringSort::operator<(const char *RHS) const {
  ...
}

} // end anonymous namespace
```

<!--
This is bad specifically because if you're looking at "``runHelper``" in the middle
of a large C++ file, that you have no immediate way to tell if it is local to
the file.  When it is marked static explicitly, this is immediately obvious.
Also, there is no reason to enclose the definition of "``operator<``" in the
namespace just because it was declared there.
-->

これは最悪です。なぜなら大きなC++ファイルの途中の「`runHelper`」を見た場合、すぐにファイルローカルかどうかを知るすべがないからです。明示的にstaticにされていれば、これはすぐ分かります。また、それが宣言されたというだけでは、名前空間に「`operator<`」の定義を含める理由になりません。

<!--

See Also
========

A lot of these comments and recommendations have been culled from other sources.
Two particularly important books for our work are:

#. `Effective C++
   <http://www.amazon.com/Effective-Specific-Addison-Wesley-Professional-Computing/dp/0321334876>`_
   by Scott Meyers.  Also interesting and useful are "More Effective C++" and
   "Effective STL" by the same author.

#. `Large-Scale C++ Software Design
   <http://www.amazon.com/Large-Scale-Software-Design-John-Lakos/dp/0201633620/ref=sr_1_1>`_
   by John Lakos

If you get some free time, and you haven't read them: do so, you might learn
something.
-->

## 関連項目

これらのコメントや勧告の多くは他の情報源から抜粋されています。特に重要な書籍を紹介します。

1. [Effective C++](http://www.amazon.com/Effective-Specific-Addison-Wesley-Professional-Computing/dp/0321334876) by Scott Meyers.同じ著者による「More Effective C++」「Effective STL」もまた、興味深く有用です。
1. [Large-Scale C++ Software Design](http://www.amazon.com/Large-Scale-Software-Design-John-Lakos/dp/0201633620/ref=sr_1_1) by John Lakos


## 原文の変更履歴

### 5.0.1 -> 6.0.0の変更

- はじめに＞その他の言語　Go Code Review Commentsのリンク先変更
- 機械的なソースの問題＞言語とコンパイラの問題＞ポインタ順序による非決定性に注意　追加
- スタイルの問題＞高位の問題＞早期終了と`continue`でコードをシンプルに　コードがシンプルに(range-based for, auto)
- スタイルの問題＞低位の問題＞たっぷりのアサート　エラーの回復について追加
- スタイルの問題＞低位の問題＞できるだけrange-based ``for``ループを使う　追加
- スタイルの問題＞低位の問題＞ループで毎回`end()`を評価しない　文言変更